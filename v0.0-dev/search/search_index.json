{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Microgrid API Client","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Microgrid API client for Python</p> <p>TODO(cookiecutter): Improve the README file</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Microgrid API Client","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>microgrid<ul> <li>metadata</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/microgrid/","title":"Index","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid","title":"frequenz.client.microgrid","text":"<p>Client to connect to the Microgrid API.</p>"},{"location":"reference/frequenz/client/microgrid/metadata/","title":"metadata","text":""},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata","title":"frequenz.client.microgrid.metadata","text":"<p>Metadata that describes a microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Location","title":"frequenz.client.microgrid.metadata.Location  <code>dataclass</code>","text":"<p>Metadata for the location of microgrid.</p> Source code in <code>frequenz/client/microgrid/metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Location:\n\"\"\"Metadata for the location of microgrid.\"\"\"\nlatitude: float | None = None\n\"\"\"The latitude of the microgrid in degree.\"\"\"\nlongitude: float | None = None\n\"\"\"The longitude of the microgrid in degree.\"\"\"\ntimezone: ZoneInfo | None = None\n\"\"\"The timezone of the microgrid.\n    The timezone will be set to None if the latitude or longitude points\n    are not set or the timezone cannot be found given the location points.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Initialize the timezone of the microgrid.\"\"\"\nif self.latitude is None or self.longitude is None or self.timezone is not None:\nreturn\ntimezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\nif timezone:\n# The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\nobject.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Location-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float | None = None\n</code></pre> <p>The latitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float | None = None\n</code></pre> <p>The longitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Location.timezone","title":"timezone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timezone: ZoneInfo | None = None\n</code></pre> <p>The timezone of the microgrid.</p> <p>The timezone will be set to None if the latitude or longitude points are not set or the timezone cannot be found given the location points.</p>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Location-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Location.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Initialize the timezone of the microgrid.</p> Source code in <code>frequenz/client/microgrid/metadata.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Initialize the timezone of the microgrid.\"\"\"\nif self.latitude is None or self.longitude is None or self.timezone is not None:\nreturn\ntimezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\nif timezone:\n# The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\nobject.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Metadata","title":"frequenz.client.microgrid.metadata.Metadata  <code>dataclass</code>","text":"<p>Metadata for the microgrid.</p> Source code in <code>frequenz/client/microgrid/metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Metadata:\n\"\"\"Metadata for the microgrid.\"\"\"\nmicrogrid_id: int | None = None\n\"\"\"The ID of the microgrid.\"\"\"\nlocation: Location | None = None\n\"\"\"The location of the microgrid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Metadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Metadata.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: Location | None = None\n</code></pre> <p>The location of the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/metadata/#frequenz.client.microgrid.metadata.Metadata.microgrid_id","title":"microgrid_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int | None = None\n</code></pre> <p>The ID of the microgrid.</p>"}]}