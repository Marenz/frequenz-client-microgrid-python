{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Microgrid API Client","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This project provides a Python client for the Frequenz Microgrid API that is more idiomatic to use in Python than the automatically-generated gRPC client provided by <code>protoc</code>.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Microgrid API Client","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>microgrid</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/microgrid/","title":"microgrid","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid","title":"frequenz.client.microgrid","text":"<p>Client to connect to the Microgrid API.</p> <p>This package provides a low-level interface for interacting with the microgrid API.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient","title":"frequenz.client.microgrid.ApiClient","text":"<p>A microgrid API client.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>class ApiClient:\n    \"\"\"A microgrid API client.\"\"\"\n\n    def __init__(\n        self,\n        server_url: str,\n        *,\n        retry_strategy: retry.Strategy | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the class instance.\n\n        Args:\n            server_url: The location of the microgrid API server in the form of a URL.\n                The following format is expected:\n                \"grpc://hostname{:`port`}{?ssl=`ssl`}\",\n                where the `port` should be an int between 0 and 65535 (defaulting to\n                9090) and `ssl` should be a boolean (defaulting to `false`).\n                For example: `grpc://localhost:1090?ssl=true`.\n            retry_strategy: The retry strategy to use to reconnect when the connection\n                to the streaming method is lost. By default a linear backoff strategy\n                is used.\n        \"\"\"\n        self._server_url = server_url\n        \"\"\"The location of the microgrid API server as a URL.\"\"\"\n\n        self.api = MicrogridStub(channel.parse_grpc_uri(server_url))\n        \"\"\"The gRPC stub for the microgrid API.\"\"\"\n\n        self._broadcasters: dict[int, streaming.GrpcStreamBroadcaster[Any, Any]] = {}\n        self._retry_strategy = retry_strategy\n\n    @property\n    def server_url(self) -&gt; str:\n        \"\"\"The server location in URL format.\"\"\"\n        return self._server_url\n\n    async def components(self) -&gt; Iterable[Component]:\n        \"\"\"Fetch all the components present in the microgrid.\n\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n\n        Raises:\n            ApiClientError: If the are any errors communicating with the Microgrid API,\n                most likely a subclass of\n                [GrpcError][frequenz.client.microgrid.GrpcError].\n        \"\"\"\n        try:\n            # grpc.aio is missing types and mypy thinks this is not awaitable,\n            # but it is\n            component_list = await cast(\n                Awaitable[PbComponentList],\n                self.api.ListComponents(\n                    PbComponentFilter(),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError as grpc_error:\n            raise ApiClientError.from_grpc_error(\n                server_url=self._server_url,\n                operation=\"ListComponents\",\n                grpc_error=grpc_error,\n            ) from grpc_error\n\n        components_only = filter(\n            lambda c: c.category is not PbComponentCategory.COMPONENT_CATEGORY_SENSOR,\n            component_list.components,\n        )\n        result: Iterable[Component] = map(\n            lambda c: Component(\n                c.id,\n                component_category_from_protobuf(c.category),\n                component_type_from_protobuf(c.category, c.inverter),\n                component_metadata_from_protobuf(c.category, c.grid),\n            ),\n            components_only,\n        )\n\n        return result\n\n    async def metadata(self) -&gt; Metadata:\n        \"\"\"Fetch the microgrid metadata.\n\n        If there is an error fetching the metadata, the microgrid ID and\n        location will be set to None.\n\n        Returns:\n            the microgrid metadata.\n        \"\"\"\n        microgrid_metadata: PbMicrogridMetadata | None = None\n        try:\n            microgrid_metadata = await cast(\n                Awaitable[PbMicrogridMetadata],\n                self.api.GetMicrogridMetadata(\n                    Empty(),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError:\n            _logger.exception(\"The microgrid metadata is not available.\")\n\n        if not microgrid_metadata:\n            return Metadata()\n\n        location: Location | None = None\n        if microgrid_metadata.location:\n            location = Location(\n                latitude=microgrid_metadata.location.latitude,\n                longitude=microgrid_metadata.location.longitude,\n            )\n\n        return Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\n\n    async def connections(\n        self,\n        starts: Set[int] = frozenset(),\n        ends: Set[int] = frozenset(),\n    ) -&gt; Iterable[Connection]:\n        \"\"\"Fetch the connections between components in the microgrid.\n\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n\n        Raises:\n            ApiClientError: If the are any errors communicating with the Microgrid API,\n                most likely a subclass of\n                [GrpcError][frequenz.client.microgrid.GrpcError].\n        \"\"\"\n        connection_filter = PbConnectionFilter(starts=starts, ends=ends)\n        try:\n            valid_components, all_connections = await asyncio.gather(\n                self.components(),\n                # grpc.aio is missing types and mypy thinks this is not\n                # awaitable, but it is\n                cast(\n                    Awaitable[PbConnectionList],\n                    self.api.ListConnections(\n                        connection_filter,\n                        timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                    ),\n                ),\n            )\n        except grpc.aio.AioRpcError as grpc_error:\n            raise ApiClientError.from_grpc_error(\n                server_url=self._server_url,\n                operation=\"ListConnections\",\n                grpc_error=grpc_error,\n            ) from grpc_error\n        # Filter out the components filtered in `components` method.\n        # id=0 is an exception indicating grid component.\n        valid_ids = {c.component_id for c in valid_components}\n        valid_ids.add(0)\n\n        connections = filter(\n            lambda c: (c.start in valid_ids and c.end in valid_ids),\n            all_connections.connections,\n        )\n\n        result: Iterable[Connection] = map(\n            lambda c: Connection(c.start, c.end), connections\n        )\n\n        return result\n\n    async def _new_component_data_receiver(\n        self,\n        *,\n        component_id: int,\n        expected_category: ComponentCategory,\n        transform: Callable[[PbComponentData], _ComponentDataT],\n        maxsize: int,\n    ) -&gt; Receiver[_ComponentDataT]:\n        \"\"\"Return a new broadcaster receiver for a given `component_id`.\n\n        If a broadcaster for the given `component_id` doesn't exist, it creates a new\n        one.\n\n        Args:\n            component_id: id of the component to get data for.\n            expected_category: Category of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            The new receiver for the given `component_id`.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            expected_category,\n        )\n\n        broadcaster = self._broadcasters.get(component_id)\n        if broadcaster is None:\n            broadcaster = streaming.GrpcStreamBroadcaster(\n                f\"raw-component-data-{component_id}\",\n                # We need to cast here because grpc says StreamComponentData is\n                # a grpc.CallIterator[PbComponentData] which is not an AsyncIterator,\n                # but it is a grpc.aio.UnaryStreamCall[..., PbComponentData], which it\n                # is.\n                lambda: cast(\n                    AsyncIterator[PbComponentData],\n                    self.api.StreamComponentData(PbComponentIdParam(id=component_id)),\n                ),\n                transform,\n                retry_strategy=self._retry_strategy,\n            )\n            self._broadcasters[component_id] = broadcaster\n        return broadcaster.new_receiver(maxsize=maxsize)\n\n    async def _expect_category(\n        self,\n        component_id: int,\n        expected_category: ComponentCategory,\n    ) -&gt; None:\n        \"\"\"Check if the given component_id is of the expected type.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: Component id to check.\n            expected_category: Component category that the given id is expected\n                to have.\n        \"\"\"\n        try:\n            comp = next(\n                comp\n                for comp in await self.components()\n                if comp.component_id == component_id\n            )\n        except StopIteration as exc:\n            raise ValueError(\n                f\"Unable to find component with id {component_id}\"\n            ) from exc\n\n        if comp.category != expected_category:\n            raise ValueError(\n                f\"Component id {component_id} is a {comp.category.name.lower()}\"\n                f\", not a {expected_category.name.lower()}.\"\n            )\n\n    async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[MeterData]:\n        \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.METER,\n            transform=MeterData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[BatteryData]:\n        \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.BATTERY,\n            transform=BatteryData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[InverterData]:\n        \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.INVERTER,\n            transform=InverterData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[EVChargerData]:\n        \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.EV_CHARGER,\n            transform=EVChargerData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def set_power(self, component_id: int, power_w: float) -&gt; None:\n        \"\"\"Send request to the Microgrid to set power for component.\n\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n\n\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n\n        Raises:\n            ApiClientError: If the are any errors communicating with the Microgrid API,\n                most likely a subclass of\n                [GrpcError][frequenz.client.microgrid.GrpcError].\n        \"\"\"\n        try:\n            await cast(\n                Awaitable[Empty],\n                self.api.SetPowerActive(\n                    PbSetPowerActiveParam(component_id=component_id, power=power_w),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError as grpc_error:\n            raise ApiClientError.from_grpc_error(\n                server_url=self._server_url,\n                operation=\"SetPowerActive\",\n                grpc_error=grpc_error,\n            ) from grpc_error\n\n    async def set_bounds(\n        self,\n        component_id: int,\n        lower: float,\n        upper: float,\n    ) -&gt; None:\n        \"\"\"Send `PbSetBoundsParam`s received from a channel to the Microgrid service.\n\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n\n        Raises:\n            ValueError: when upper bound is less than 0, or when lower bound is\n                greater than 0.\n            ApiClientError: If the are any errors communicating with the Microgrid API,\n                most likely a subclass of\n                [GrpcError][frequenz.client.microgrid.GrpcError].\n        \"\"\"\n        if upper &lt; 0:\n            raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n        if lower &gt; 0:\n            raise ValueError(f\"Lower bound {lower} must be less than or equal to 0.\")\n\n        target_metric = PbSetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n        try:\n            await cast(\n                Awaitable[Timestamp],\n                self.api.AddInclusionBounds(\n                    PbSetBoundsParam(\n                        component_id=component_id,\n                        target_metric=target_metric,\n                        bounds=PbBounds(lower=lower, upper=upper),\n                    ),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError as grpc_error:\n            raise ApiClientError.from_grpc_error(\n                server_url=self._server_url,\n                operation=\"AddInclusionBounds\",\n                grpc_error=grpc_error,\n            ) from grpc_error\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api = MicrogridStub(parse_grpc_uri(server_url))\n</code></pre> <p>The gRPC stub for the microgrid API.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre> <p>The server location in URL format.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.__init__","title":"__init__","text":"<pre><code>__init__(\n    server_url: str,\n    *,\n    retry_strategy: Strategy | None = None\n) -&gt; None\n</code></pre> <p>Initialize the class instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The location of the microgrid API server in the form of a URL. The following format is expected: \"grpc://hostname{:<code>port</code>}{?ssl=<code>ssl</code>}\", where the <code>port</code> should be an int between 0 and 65535 (defaulting to 9090) and <code>ssl</code> should be a boolean (defaulting to <code>false</code>). For example: <code>grpc://localhost:1090?ssl=true</code>.</p> <p> TYPE: <code>str</code> </p> <code>retry_strategy</code> <p>The retry strategy to use to reconnect when the connection to the streaming method is lost. By default a linear backoff strategy is used.</p> <p> TYPE: <code>Strategy | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>def __init__(\n    self,\n    server_url: str,\n    *,\n    retry_strategy: retry.Strategy | None = None,\n) -&gt; None:\n    \"\"\"Initialize the class instance.\n\n    Args:\n        server_url: The location of the microgrid API server in the form of a URL.\n            The following format is expected:\n            \"grpc://hostname{:`port`}{?ssl=`ssl`}\",\n            where the `port` should be an int between 0 and 65535 (defaulting to\n            9090) and `ssl` should be a boolean (defaulting to `false`).\n            For example: `grpc://localhost:1090?ssl=true`.\n        retry_strategy: The retry strategy to use to reconnect when the connection\n            to the streaming method is lost. By default a linear backoff strategy\n            is used.\n    \"\"\"\n    self._server_url = server_url\n    \"\"\"The location of the microgrid API server as a URL.\"\"\"\n\n    self.api = MicrogridStub(channel.parse_grpc_uri(server_url))\n    \"\"\"The gRPC stub for the microgrid API.\"\"\"\n\n    self._broadcasters: dict[int, streaming.GrpcStreamBroadcaster[Any, Any]] = {}\n    self._retry_strategy = retry_strategy\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.battery_data","title":"battery_data  <code>async</code>","text":"<pre><code>battery_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[BatteryData]\n</code></pre> <p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n    \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.BATTERY,\n        transform=BatteryData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.components","title":"components  <code>async</code>","text":"<pre><code>components() -&gt; Iterable[Component]\n</code></pre> <p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> RAISES DESCRIPTION <code>ApiClientError</code> <p>If the are any errors communicating with the Microgrid API, most likely a subclass of GrpcError.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def components(self) -&gt; Iterable[Component]:\n    \"\"\"Fetch all the components present in the microgrid.\n\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n\n    Raises:\n        ApiClientError: If the are any errors communicating with the Microgrid API,\n            most likely a subclass of\n            [GrpcError][frequenz.client.microgrid.GrpcError].\n    \"\"\"\n    try:\n        # grpc.aio is missing types and mypy thinks this is not awaitable,\n        # but it is\n        component_list = await cast(\n            Awaitable[PbComponentList],\n            self.api.ListComponents(\n                PbComponentFilter(),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError as grpc_error:\n        raise ApiClientError.from_grpc_error(\n            server_url=self._server_url,\n            operation=\"ListComponents\",\n            grpc_error=grpc_error,\n        ) from grpc_error\n\n    components_only = filter(\n        lambda c: c.category is not PbComponentCategory.COMPONENT_CATEGORY_SENSOR,\n        component_list.components,\n    )\n    result: Iterable[Component] = map(\n        lambda c: Component(\n            c.id,\n            component_category_from_protobuf(c.category),\n            component_type_from_protobuf(c.category, c.inverter),\n            component_metadata_from_protobuf(c.category, c.grid),\n        ),\n        components_only,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.connections","title":"connections  <code>async</code>","text":"<pre><code>connections(\n    starts: Set[int] = frozenset(),\n    ends: Set[int] = frozenset(),\n) -&gt; Iterable[Connection]\n</code></pre> <p>Fetch the connections between components in the microgrid.</p> PARAMETER DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>Set[int]</code> DEFAULT: <code>frozenset()</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>Set[int]</code> DEFAULT: <code>frozenset()</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> RAISES DESCRIPTION <code>ApiClientError</code> <p>If the are any errors communicating with the Microgrid API, most likely a subclass of GrpcError.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def connections(\n    self,\n    starts: Set[int] = frozenset(),\n    ends: Set[int] = frozenset(),\n) -&gt; Iterable[Connection]:\n    \"\"\"Fetch the connections between components in the microgrid.\n\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n\n    Raises:\n        ApiClientError: If the are any errors communicating with the Microgrid API,\n            most likely a subclass of\n            [GrpcError][frequenz.client.microgrid.GrpcError].\n    \"\"\"\n    connection_filter = PbConnectionFilter(starts=starts, ends=ends)\n    try:\n        valid_components, all_connections = await asyncio.gather(\n            self.components(),\n            # grpc.aio is missing types and mypy thinks this is not\n            # awaitable, but it is\n            cast(\n                Awaitable[PbConnectionList],\n                self.api.ListConnections(\n                    connection_filter,\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            ),\n        )\n    except grpc.aio.AioRpcError as grpc_error:\n        raise ApiClientError.from_grpc_error(\n            server_url=self._server_url,\n            operation=\"ListConnections\",\n            grpc_error=grpc_error,\n        ) from grpc_error\n    # Filter out the components filtered in `components` method.\n    # id=0 is an exception indicating grid component.\n    valid_ids = {c.component_id for c in valid_components}\n    valid_ids.add(0)\n\n    connections = filter(\n        lambda c: (c.start in valid_ids and c.end in valid_ids),\n        all_connections.connections,\n    )\n\n    result: Iterable[Connection] = map(\n        lambda c: Connection(c.start, c.end), connections\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.ev_charger_data","title":"ev_charger_data  <code>async</code>","text":"<pre><code>ev_charger_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n    \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.EV_CHARGER,\n        transform=EVChargerData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.inverter_data","title":"inverter_data  <code>async</code>","text":"<pre><code>inverter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[InverterData]\n</code></pre> <p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n    \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.INVERTER,\n        transform=InverterData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.metadata","title":"metadata  <code>async</code>","text":"<pre><code>metadata() -&gt; Metadata\n</code></pre> <p>Fetch the microgrid metadata.</p> <p>If there is an error fetching the metadata, the microgrid ID and location will be set to None.</p> RETURNS DESCRIPTION <code>Metadata</code> <p>the microgrid metadata.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def metadata(self) -&gt; Metadata:\n    \"\"\"Fetch the microgrid metadata.\n\n    If there is an error fetching the metadata, the microgrid ID and\n    location will be set to None.\n\n    Returns:\n        the microgrid metadata.\n    \"\"\"\n    microgrid_metadata: PbMicrogridMetadata | None = None\n    try:\n        microgrid_metadata = await cast(\n            Awaitable[PbMicrogridMetadata],\n            self.api.GetMicrogridMetadata(\n                Empty(),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError:\n        _logger.exception(\"The microgrid metadata is not available.\")\n\n    if not microgrid_metadata:\n        return Metadata()\n\n    location: Location | None = None\n    if microgrid_metadata.location:\n        location = Location(\n            latitude=microgrid_metadata.location.latitude,\n            longitude=microgrid_metadata.location.longitude,\n        )\n\n    return Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.meter_data","title":"meter_data  <code>async</code>","text":"<pre><code>meter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[MeterData]\n</code></pre> <p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n    \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.METER,\n        transform=MeterData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.set_bounds","title":"set_bounds  <code>async</code>","text":"<pre><code>set_bounds(\n    component_id: int, lower: float, upper: float\n) -&gt; None\n</code></pre> <p>Send <code>PbSetBoundsParam</code>s received from a channel to the Microgrid service.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>when upper bound is less than 0, or when lower bound is greater than 0.</p> <code>ApiClientError</code> <p>If the are any errors communicating with the Microgrid API, most likely a subclass of GrpcError.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def set_bounds(\n    self,\n    component_id: int,\n    lower: float,\n    upper: float,\n) -&gt; None:\n    \"\"\"Send `PbSetBoundsParam`s received from a channel to the Microgrid service.\n\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n\n    Raises:\n        ValueError: when upper bound is less than 0, or when lower bound is\n            greater than 0.\n        ApiClientError: If the are any errors communicating with the Microgrid API,\n            most likely a subclass of\n            [GrpcError][frequenz.client.microgrid.GrpcError].\n    \"\"\"\n    if upper &lt; 0:\n        raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n    if lower &gt; 0:\n        raise ValueError(f\"Lower bound {lower} must be less than or equal to 0.\")\n\n    target_metric = PbSetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n    try:\n        await cast(\n            Awaitable[Timestamp],\n            self.api.AddInclusionBounds(\n                PbSetBoundsParam(\n                    component_id=component_id,\n                    target_metric=target_metric,\n                    bounds=PbBounds(lower=lower, upper=upper),\n                ),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError as grpc_error:\n        raise ApiClientError.from_grpc_error(\n            server_url=self._server_url,\n            operation=\"AddInclusionBounds\",\n            grpc_error=grpc_error,\n        ) from grpc_error\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(component_id: int, power_w: float) -&gt; None\n</code></pre> <p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ApiClientError</code> <p>If the are any errors communicating with the Microgrid API, most likely a subclass of GrpcError.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def set_power(self, component_id: int, power_w: float) -&gt; None:\n    \"\"\"Send request to the Microgrid to set power for component.\n\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n\n\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n\n    Raises:\n        ApiClientError: If the are any errors communicating with the Microgrid API,\n            most likely a subclass of\n            [GrpcError][frequenz.client.microgrid.GrpcError].\n    \"\"\"\n    try:\n        await cast(\n            Awaitable[Empty],\n            self.api.SetPowerActive(\n                PbSetPowerActiveParam(component_id=component_id, power=power_w),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError as grpc_error:\n        raise ApiClientError.from_grpc_error(\n            server_url=self._server_url,\n            operation=\"SetPowerActive\",\n            grpc_error=grpc_error,\n        ) from grpc_error\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError","title":"frequenz.client.microgrid.ApiClientError","text":"<p>               Bases: <code>Exception</code></p> <p>There was an error in an API client.</p> <p>To simplify retrying, errors are classified as retryable, or not. Retryable errors might succeed if retried, while permanent errors won't. When uncertain, errors are assumed to be retryable.</p> <p>The following sub-classes are available:</p> <ul> <li>GrpcError: A gRPC operation failed.</li> </ul> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ApiClientError(Exception):\n    \"\"\"There was an error in an API client.\n\n    To simplify retrying, errors are classified as\n    [retryable][frequenz.client.base.exception.ApiClientError.is_retryable], or not.\n    Retryable errors might succeed if retried, while permanent errors won't. When\n    uncertain, errors are assumed to be retryable.\n\n    The following sub-classes are available:\n\n    - [GrpcError][frequenz.client.base.exception.GrpcError]: A gRPC operation failed.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        server_url: str,\n        operation: str,\n        description: str,\n        retryable: bool,\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            description: A human-readable description of the error.\n            retryable: Whether retrying the operation might succeed.\n        \"\"\"\n        super().__init__(\n            f\"Failed calling {operation!r} on {server_url!r}: {description}\"\n        )\n\n        self.server_url = server_url\n        \"\"\"The URL of the server that returned the error.\"\"\"\n\n        self.operation = operation\n        \"\"\"The operation that caused the error.\"\"\"\n\n        self.description = description\n        \"\"\"The human-readable description of the error.\"\"\"\n\n        self.is_retryable = retryable\n        \"\"\"Whether retrying the operation might succeed.\"\"\"\n\n    @classmethod\n    def from_grpc_error(\n        cls,\n        *,\n        server_url: str,\n        operation: str,\n        grpc_error: AioRpcError,\n    ) -&gt; GrpcError:\n        \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error to convert.\n\n        Returns:\n            An instance of\n                [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n                is not recognized, or an appropriate subclass if it is.\n        \"\"\"\n\n        class Ctor(Protocol):\n            \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n            def __call__(\n                self, *, server_url: str, operation: str, grpc_error: AioRpcError\n            ) -&gt; GrpcError: ...\n\n        grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n            grpc.StatusCode.CANCELLED: OperationCancelled,\n            grpc.StatusCode.UNKNOWN: UnknownError,\n            grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n            grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n            grpc.StatusCode.NOT_FOUND: EntityNotFound,\n            grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n            grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n            grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n            grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n            grpc.StatusCode.ABORTED: OperationAborted,\n            grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n            grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n            grpc.StatusCode.INTERNAL: InternalError,\n            grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n            grpc.StatusCode.DATA_LOSS: DataLoss,\n            grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n        }\n\n        if ctor := grpc_status_map.get(grpc_error.code()):\n            return ctor(\n                server_url=server_url, operation=operation, grpc_error=grpc_error\n            )\n        return UnrecognizedGrpcStatus(\n            server_url=server_url,\n            operation=operation,\n            grpc_error=grpc_error,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    retryable: bool\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>A human-readable description of the error.</p> <p> TYPE: <code>str</code> </p> <code>retryable</code> <p>Whether retrying the operation might succeed.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self,\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    retryable: bool,\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        description: A human-readable description of the error.\n        retryable: Whether retrying the operation might succeed.\n    \"\"\"\n    super().__init__(\n        f\"Failed calling {operation!r} on {server_url!r}: {description}\"\n    )\n\n    self.server_url = server_url\n    \"\"\"The URL of the server that returned the error.\"\"\"\n\n    self.operation = operation\n    \"\"\"The operation that caused the error.\"\"\"\n\n    self.description = description\n    \"\"\"The human-readable description of the error.\"\"\"\n\n    self.is_retryable = retryable\n    \"\"\"Whether retrying the operation might succeed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClientError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState","title":"frequenz.client.microgrid.BatteryComponentState","text":"<p>               Bases: <code>Enum</code></p> <p>Component states of a battery.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>class BatteryComponentState(Enum):\n    \"\"\"Component states of a battery.\"\"\"\n\n    UNSPECIFIED = PbBatteryComponentState.COMPONENT_STATE_UNSPECIFIED\n    \"\"\"Unspecified component state.\"\"\"\n\n    OFF = PbBatteryComponentState.COMPONENT_STATE_OFF\n    \"\"\"The battery is switched off.\"\"\"\n\n    IDLE = PbBatteryComponentState.COMPONENT_STATE_IDLE\n    \"\"\"The battery is idle.\"\"\"\n\n    CHARGING = PbBatteryComponentState.COMPONENT_STATE_CHARGING\n    \"\"\"The battery is consuming electrical energy.\"\"\"\n\n    DISCHARGING = PbBatteryComponentState.COMPONENT_STATE_DISCHARGING\n    \"\"\"The battery is generating electrical energy.\"\"\"\n\n    ERROR = PbBatteryComponentState.COMPONENT_STATE_ERROR\n    \"\"\"The battery is in a faulty state.\"\"\"\n\n    LOCKED = PbBatteryComponentState.COMPONENT_STATE_LOCKED\n    \"\"\"The battery is online, but currently unavailable.\n\n    Possibly due to a pre-scheduled maintenance, or waiting for a resource to be loaded.\n    \"\"\"\n\n    SWITCHING_ON = PbBatteryComponentState.COMPONENT_STATE_SWITCHING_ON\n    \"\"\"\n    The battery is starting up and needs some time to become fully operational.\n    \"\"\"\n\n    SWITCHING_OFF = PbBatteryComponentState.COMPONENT_STATE_SWITCHING_OFF\n    \"\"\"The battery is switching off and needs some time to fully shut down.\"\"\"\n\n    UNKNOWN = PbBatteryComponentState.COMPONENT_STATE_UNKNOWN\n    \"\"\"A state is provided by the component, but it is not one of the above states.\"\"\"\n\n    @classmethod\n    def from_pb(cls, state: PbBatteryComponentState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf state value to this enum.\n\n        Args:\n            state: The protobuf component state to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(state)\n        except ValueError:\n            return cls(cls.UNKNOWN)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.CHARGING","title":"CHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING = COMPONENT_STATE_CHARGING\n</code></pre> <p>The battery is consuming electrical energy.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.DISCHARGING","title":"DISCHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCHARGING = COMPONENT_STATE_DISCHARGING\n</code></pre> <p>The battery is generating electrical energy.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = COMPONENT_STATE_ERROR\n</code></pre> <p>The battery is in a faulty state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.IDLE","title":"IDLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE = COMPONENT_STATE_IDLE\n</code></pre> <p>The battery is idle.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.LOCKED","title":"LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOCKED = COMPONENT_STATE_LOCKED\n</code></pre> <p>The battery is online, but currently unavailable.</p> <p>Possibly due to a pre-scheduled maintenance, or waiting for a resource to be loaded.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.OFF","title":"OFF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFF = COMPONENT_STATE_OFF\n</code></pre> <p>The battery is switched off.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.SWITCHING_OFF","title":"SWITCHING_OFF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SWITCHING_OFF = COMPONENT_STATE_SWITCHING_OFF\n</code></pre> <p>The battery is switching off and needs some time to fully shut down.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.SWITCHING_ON","title":"SWITCHING_ON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SWITCHING_ON = COMPONENT_STATE_SWITCHING_ON\n</code></pre> <p>The battery is starting up and needs some time to become fully operational.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = COMPONENT_STATE_UNKNOWN\n</code></pre> <p>A state is provided by the component, but it is not one of the above states.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = COMPONENT_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified component state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryComponentState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf state value to this enum.</p> PARAMETER DESCRIPTION <code>state</code> <p>The protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(cls, state: PbBatteryComponentState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf state value to this enum.\n\n    Args:\n        state: The protobuf component state to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(state)\n    except ValueError:\n        return cls(cls.UNKNOWN)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData","title":"frequenz.client.microgrid.BatteryData  <code>dataclass</code>","text":"<p>               Bases: <code>ComponentData</code></p> <p>A wrapper class for holding battery data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass BatteryData(ComponentData):  # pylint: disable=too-many-instance-attributes\n    \"\"\"A wrapper class for holding battery data.\"\"\"\n\n    soc: float\n    \"\"\"Battery's overall SoC in percent (%).\"\"\"\n\n    soc_lower_bound: float\n    \"\"\"The SoC below which discharge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    soc_upper_bound: float\n    \"\"\"The SoC above which charge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    capacity: float\n    \"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\"\n\n    power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for battery power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for battery power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for battery power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for battery power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    temperature: float\n    \"\"\"The (average) temperature reported by the battery, in Celsius (\u00b0C).\"\"\"\n\n    relay_state: BatteryRelayState\n    \"\"\"State of the battery relay.\"\"\"\n\n    component_state: BatteryComponentState\n    \"\"\"State of the battery.\"\"\"\n\n    errors: list[BatteryError]\n    \"\"\"List of errors in protobuf struct.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create BatteryData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of BatteryData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.battery.data.dc.power\n        battery_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            soc=raw.battery.data.soc.avg,\n            soc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\n            soc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\n            capacity=raw.battery.properties.capacity,\n            power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            temperature=raw.battery.data.temperature.avg,\n            relay_state=BatteryRelayState.from_pb(raw.battery.state.relay_state),\n            component_state=BatteryComponentState.from_pb(\n                raw.battery.state.component_state\n            ),\n            errors=[BatteryError.from_pb(e) for e in raw.battery.errors],\n        )\n        battery_data._set_raw(raw=raw)\n        return battery_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.capacity","title":"capacity  <code>instance-attribute</code>","text":"<pre><code>capacity: float\n</code></pre> <p>The capacity of the battery in Wh (Watt-hour).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.component_state","title":"component_state  <code>instance-attribute</code>","text":"<pre><code>component_state: BatteryComponentState\n</code></pre> <p>State of the battery.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: list[BatteryError]\n</code></pre> <p>List of errors in protobuf struct.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_exclusion_lower_bound","title":"power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_exclusion_upper_bound","title":"power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_inclusion_lower_bound","title":"power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_inclusion_upper_bound","title":"power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.relay_state","title":"relay_state  <code>instance-attribute</code>","text":"<pre><code>relay_state: BatteryRelayState\n</code></pre> <p>State of the battery relay.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.soc","title":"soc  <code>instance-attribute</code>","text":"<pre><code>soc: float\n</code></pre> <p>Battery's overall SoC in percent (%).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.soc_lower_bound","title":"soc_lower_bound  <code>instance-attribute</code>","text":"<pre><code>soc_lower_bound: float\n</code></pre> <p>The SoC below which discharge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.soc_upper_bound","title":"soc_upper_bound  <code>instance-attribute</code>","text":"<pre><code>soc_upper_bound: float\n</code></pre> <p>The SoC above which charge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature: float\n</code></pre> <p>The (average) temperature reported by the battery, in Celsius (\u00b0C).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create BatteryData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of BatteryData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create BatteryData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of BatteryData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.battery.data.dc.power\n    battery_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        soc=raw.battery.data.soc.avg,\n        soc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\n        soc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\n        capacity=raw.battery.properties.capacity,\n        power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        temperature=raw.battery.data.temperature.avg,\n        relay_state=BatteryRelayState.from_pb(raw.battery.state.relay_state),\n        component_state=BatteryComponentState.from_pb(\n            raw.battery.state.component_state\n        ),\n        errors=[BatteryError.from_pb(e) for e in raw.battery.errors],\n    )\n    battery_data._set_raw(raw=raw)\n    return battery_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryError","title":"frequenz.client.microgrid.BatteryError  <code>dataclass</code>","text":"<p>A battery error.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass BatteryError:\n    \"\"\"A battery error.\"\"\"\n\n    code: BatteryErrorCode = BatteryErrorCode.UNSPECIFIED\n    \"\"\"The error code.\"\"\"\n\n    level: ErrorLevel = ErrorLevel.UNSPECIFIED\n    \"\"\"The error level.\"\"\"\n\n    message: str = \"\"\n    \"\"\"The error message.\"\"\"\n\n    @classmethod\n    def from_pb(cls, raw: PbBatteryError) -&gt; Self:\n        \"\"\"Create a new instance using a protobuf message to get the values.\n\n        Args:\n            raw: The protobuf message to get the values from.\n\n        Returns:\n            The new instance with the values from the protobuf message.\n        \"\"\"\n        return cls(\n            code=BatteryErrorCode.from_pb(raw.code),\n            level=ErrorLevel.from_pb(raw.level),\n            message=raw.msg,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryError.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: BatteryErrorCode = UNSPECIFIED\n</code></pre> <p>The error code.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryError.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: ErrorLevel = UNSPECIFIED\n</code></pre> <p>The error level.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = ''\n</code></pre> <p>The error message.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryError.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(raw: Error) -&gt; Self\n</code></pre> <p>Create a new instance using a protobuf message to get the values.</p> PARAMETER DESCRIPTION <code>raw</code> <p>The protobuf message to get the values from.</p> <p> TYPE: <code>Error</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The new instance with the values from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>@classmethod\ndef from_pb(cls, raw: PbBatteryError) -&gt; Self:\n    \"\"\"Create a new instance using a protobuf message to get the values.\n\n    Args:\n        raw: The protobuf message to get the values from.\n\n    Returns:\n        The new instance with the values from the protobuf message.\n    \"\"\"\n    return cls(\n        code=BatteryErrorCode.from_pb(raw.code),\n        level=ErrorLevel.from_pb(raw.level),\n        message=raw.msg,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode","title":"frequenz.client.microgrid.BatteryErrorCode","text":"<p>               Bases: <code>Enum</code></p> <p>Battery error code.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>class BatteryErrorCode(Enum):\n    \"\"\"Battery error code.\"\"\"\n\n    UNSPECIFIED = PbBatteryErrorCode.ERROR_CODE_UNSPECIFIED\n    \"\"\"Unspecified battery error code.\"\"\"\n\n    HIGH_CURRENT_CHARGE = PbBatteryErrorCode.ERROR_CODE_HIGH_CURRENT_CHARGE\n    \"\"\"Charge current is too high.\"\"\"\n\n    HIGH_CURRENT_DISCHARGE = PbBatteryErrorCode.ERROR_CODE_HIGH_CURRENT_DISCHARGE\n    \"\"\"Discharge current is too high.\"\"\"\n\n    HIGH_VOLTAGE = PbBatteryErrorCode.ERROR_CODE_HIGH_VOLTAGE\n    \"\"\"Voltage is too high.\"\"\"\n\n    LOW_VOLTAGE = PbBatteryErrorCode.ERROR_CODE_LOW_VOLTAGE\n    \"\"\"Voltage is too low.\"\"\"\n\n    HIGH_TEMPERATURE = PbBatteryErrorCode.ERROR_CODE_HIGH_TEMPERATURE\n    \"\"\"Temperature is too high.\"\"\"\n\n    LOW_TEMPERATURE = PbBatteryErrorCode.ERROR_CODE_LOW_TEMPERATURE\n    \"\"\"Temperature is too low.\"\"\"\n\n    HIGH_HUMIDITY = PbBatteryErrorCode.ERROR_CODE_HIGH_HUMIDITY\n    \"\"\"Humidity is too high.\"\"\"\n\n    EXCEEDED_SOP_CHARGE = PbBatteryErrorCode.ERROR_CODE_EXCEEDED_SOP_CHARGE\n    \"\"\"Charge current has exceeded component bounds.\"\"\"\n\n    EXCEEDED_SOP_DISCHARGE = PbBatteryErrorCode.ERROR_CODE_EXCEEDED_SOP_DISCHARGE\n    \"\"\"Discharge current has exceeded component bounds.\"\"\"\n\n    SYSTEM_IMBALANCE = PbBatteryErrorCode.ERROR_CODE_SYSTEM_IMBALANCE\n    \"\"\"The battery blocks are not balanced with respect to each other.\"\"\"\n\n    LOW_SOH = PbBatteryErrorCode.ERROR_CODE_LOW_SOH\n    \"\"\"The State of health is low.\"\"\"\n\n    BLOCK_ERROR = PbBatteryErrorCode.ERROR_CODE_BLOCK_ERROR\n    \"\"\"One or more battery blocks have failed.\"\"\"\n\n    CONTROLLER_ERROR = PbBatteryErrorCode.ERROR_CODE_CONTROLLER_ERROR\n    \"\"\"The battery controller has failed.\"\"\"\n\n    RELAY_ERROR = PbBatteryErrorCode.ERROR_CODE_RELAY_ERROR\n    \"\"\"The battery's DC relays have failed.\"\"\"\n\n    RELAY_CYCLE_LIMIT_REACHED = PbBatteryErrorCode.ERROR_CODE_RELAY_CYCLE_LIMIT_REACHED\n    \"\"\"The battery's DC relays have reached the cycles limit in its lifetime specifications.\"\"\"\n\n    FUSE_ERROR = PbBatteryErrorCode.ERROR_CODE_FUSE_ERROR\n    \"\"\"The battery's fuse has failed.\"\"\"\n\n    EXTERNAL_POWER_SWITCH_ERROR = (\n        PbBatteryErrorCode.ERROR_CODE_EXTERNAL_POWER_SWITCH_ERROR\n    )\n    \"\"\"The eternal power switch has failed.\"\"\"\n\n    PRECHARGE_ERROR = PbBatteryErrorCode.ERROR_CODE_PRECHARGE_ERROR\n    \"\"\"The precharge operation has failed.\"\"\"\n\n    SYSTEM_PLAUSIBILITY_ERROR = PbBatteryErrorCode.ERROR_CODE_SYSTEM_PLAUSIBILITY_ERROR\n    \"\"\"System plausibility checks have failed.\"\"\"\n\n    SYSTEM_UNDERVOLTAGE_SHUTDOWN = (\n        PbBatteryErrorCode.ERROR_CODE_SYSTEM_UNDERVOLTAGE_SHUTDOWN\n    )\n    \"\"\"System shut down due to extremely low voltage.\"\"\"\n\n    CALIBRATION_NEEDED = PbBatteryErrorCode.ERROR_CODE_CALIBRATION_NEEDED\n    \"\"\"The battery requires a calibration to reset its measurements.\"\"\"\n\n    @classmethod\n    def from_pb(cls, code: PbBatteryErrorCode.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf error code value to this enum.\n\n        Args:\n            code: The protobuf error code to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(code)\n        except ValueError:\n            return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.BLOCK_ERROR","title":"BLOCK_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCK_ERROR = ERROR_CODE_BLOCK_ERROR\n</code></pre> <p>One or more battery blocks have failed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.CALIBRATION_NEEDED","title":"CALIBRATION_NEEDED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CALIBRATION_NEEDED = ERROR_CODE_CALIBRATION_NEEDED\n</code></pre> <p>The battery requires a calibration to reset its measurements.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.CONTROLLER_ERROR","title":"CONTROLLER_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTROLLER_ERROR = ERROR_CODE_CONTROLLER_ERROR\n</code></pre> <p>The battery controller has failed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.EXCEEDED_SOP_CHARGE","title":"EXCEEDED_SOP_CHARGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXCEEDED_SOP_CHARGE = ERROR_CODE_EXCEEDED_SOP_CHARGE\n</code></pre> <p>Charge current has exceeded component bounds.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.EXCEEDED_SOP_DISCHARGE","title":"EXCEEDED_SOP_DISCHARGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXCEEDED_SOP_DISCHARGE = ERROR_CODE_EXCEEDED_SOP_DISCHARGE\n</code></pre> <p>Discharge current has exceeded component bounds.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.EXTERNAL_POWER_SWITCH_ERROR","title":"EXTERNAL_POWER_SWITCH_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXTERNAL_POWER_SWITCH_ERROR = (\n    ERROR_CODE_EXTERNAL_POWER_SWITCH_ERROR\n)\n</code></pre> <p>The eternal power switch has failed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.FUSE_ERROR","title":"FUSE_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUSE_ERROR = ERROR_CODE_FUSE_ERROR\n</code></pre> <p>The battery's fuse has failed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.HIGH_CURRENT_CHARGE","title":"HIGH_CURRENT_CHARGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH_CURRENT_CHARGE = ERROR_CODE_HIGH_CURRENT_CHARGE\n</code></pre> <p>Charge current is too high.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.HIGH_CURRENT_DISCHARGE","title":"HIGH_CURRENT_DISCHARGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH_CURRENT_DISCHARGE = ERROR_CODE_HIGH_CURRENT_DISCHARGE\n</code></pre> <p>Discharge current is too high.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.HIGH_HUMIDITY","title":"HIGH_HUMIDITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH_HUMIDITY = ERROR_CODE_HIGH_HUMIDITY\n</code></pre> <p>Humidity is too high.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.HIGH_TEMPERATURE","title":"HIGH_TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH_TEMPERATURE = ERROR_CODE_HIGH_TEMPERATURE\n</code></pre> <p>Temperature is too high.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.HIGH_VOLTAGE","title":"HIGH_VOLTAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH_VOLTAGE = ERROR_CODE_HIGH_VOLTAGE\n</code></pre> <p>Voltage is too high.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.LOW_SOH","title":"LOW_SOH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW_SOH = ERROR_CODE_LOW_SOH\n</code></pre> <p>The State of health is low.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.LOW_TEMPERATURE","title":"LOW_TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW_TEMPERATURE = ERROR_CODE_LOW_TEMPERATURE\n</code></pre> <p>Temperature is too low.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.LOW_VOLTAGE","title":"LOW_VOLTAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW_VOLTAGE = ERROR_CODE_LOW_VOLTAGE\n</code></pre> <p>Voltage is too low.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.PRECHARGE_ERROR","title":"PRECHARGE_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRECHARGE_ERROR = ERROR_CODE_PRECHARGE_ERROR\n</code></pre> <p>The precharge operation has failed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.RELAY_CYCLE_LIMIT_REACHED","title":"RELAY_CYCLE_LIMIT_REACHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RELAY_CYCLE_LIMIT_REACHED = (\n    ERROR_CODE_RELAY_CYCLE_LIMIT_REACHED\n)\n</code></pre> <p>The battery's DC relays have reached the cycles limit in its lifetime specifications.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.RELAY_ERROR","title":"RELAY_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RELAY_ERROR = ERROR_CODE_RELAY_ERROR\n</code></pre> <p>The battery's DC relays have failed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.SYSTEM_IMBALANCE","title":"SYSTEM_IMBALANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM_IMBALANCE = ERROR_CODE_SYSTEM_IMBALANCE\n</code></pre> <p>The battery blocks are not balanced with respect to each other.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.SYSTEM_PLAUSIBILITY_ERROR","title":"SYSTEM_PLAUSIBILITY_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM_PLAUSIBILITY_ERROR = (\n    ERROR_CODE_SYSTEM_PLAUSIBILITY_ERROR\n)\n</code></pre> <p>System plausibility checks have failed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.SYSTEM_UNDERVOLTAGE_SHUTDOWN","title":"SYSTEM_UNDERVOLTAGE_SHUTDOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM_UNDERVOLTAGE_SHUTDOWN = (\n    ERROR_CODE_SYSTEM_UNDERVOLTAGE_SHUTDOWN\n)\n</code></pre> <p>System shut down due to extremely low voltage.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ERROR_CODE_UNSPECIFIED\n</code></pre> <p>Unspecified battery error code.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryErrorCode.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(code: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf error code value to this enum.</p> PARAMETER DESCRIPTION <code>code</code> <p>The protobuf error code to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>@classmethod\ndef from_pb(cls, code: PbBatteryErrorCode.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf error code value to this enum.\n\n    Args:\n        code: The protobuf error code to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(code)\n    except ValueError:\n        return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState","title":"frequenz.client.microgrid.BatteryRelayState","text":"<p>               Bases: <code>Enum</code></p> <p>Relay states of a battery.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>class BatteryRelayState(Enum):\n    \"\"\"Relay states of a battery.\"\"\"\n\n    UNSPECIFIED = PbBatteryRelayState.RELAY_STATE_UNSPECIFIED\n    \"\"\"Unspecified relay state.\"\"\"\n\n    OPENED = PbBatteryRelayState.RELAY_STATE_OPENED\n    \"\"\"The relays are open, and the DC power line to the inverter is disconnected.\"\"\"\n\n    PRECHARGING = PbBatteryRelayState.RELAY_STATE_PRECHARGING\n    \"\"\"The relays are closing, and the DC power line to the inverter is being connected.\"\"\"\n\n    CLOSED = PbBatteryRelayState.RELAY_STATE_CLOSED\n    \"\"\"The relays are closed, and the DC power line to the inverter is connected.\"\"\"\n\n    ERROR = PbBatteryRelayState.RELAY_STATE_ERROR\n    \"\"\"The relays are in an error state.\"\"\"\n\n    LOCKED = PbBatteryRelayState.RELAY_STATE_LOCKED\n    \"\"\"The relays are locked, and should be available to accept commands shortly.\"\"\"\n\n    @classmethod\n    def from_pb(cls, state: PbBatteryRelayState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf state value to this enum.\n\n        Args:\n            state: The protobuf component state to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(state)\n        except ValueError:\n            return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState.CLOSED","title":"CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLOSED = RELAY_STATE_CLOSED\n</code></pre> <p>The relays are closed, and the DC power line to the inverter is connected.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = RELAY_STATE_ERROR\n</code></pre> <p>The relays are in an error state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState.LOCKED","title":"LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOCKED = RELAY_STATE_LOCKED\n</code></pre> <p>The relays are locked, and should be available to accept commands shortly.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState.OPENED","title":"OPENED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OPENED = RELAY_STATE_OPENED\n</code></pre> <p>The relays are open, and the DC power line to the inverter is disconnected.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState.PRECHARGING","title":"PRECHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRECHARGING = RELAY_STATE_PRECHARGING\n</code></pre> <p>The relays are closing, and the DC power line to the inverter is being connected.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = RELAY_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified relay state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryRelayState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf state value to this enum.</p> PARAMETER DESCRIPTION <code>state</code> <p>The protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(cls, state: PbBatteryRelayState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf state value to this enum.\n\n    Args:\n        state: The protobuf component state to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(state)\n    except ValueError:\n        return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected","title":"frequenz.client.microgrid.ClientNotConnected","text":"<p>               Bases: <code>ApiClientError</code></p> <p>The client is not connected to the server.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ClientNotConnected(ApiClientError):\n    \"\"\"The client is not connected to the server.\"\"\"\n\n    def __init__(self, *, server_url: str, operation: str) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The client is not connected to the server\",\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected.__init__","title":"__init__","text":"<pre><code>__init__(*, server_url: str, operation: str) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(self, *, server_url: str, operation: str) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The client is not connected to the server\",\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ClientNotConnected.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component","title":"frequenz.client.microgrid.Component  <code>dataclass</code>","text":"<p>Metadata for a single microgrid component.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Component:\n    \"\"\"Metadata for a single microgrid component.\"\"\"\n\n    component_id: int\n    \"\"\"The ID of this component.\"\"\"\n\n    category: ComponentCategory\n    \"\"\"The category of this component.\"\"\"\n\n    type: ComponentType | None = None\n    \"\"\"The type of this component.\"\"\"\n\n    metadata: ComponentMetadata | None = None\n    \"\"\"The metadata of this component.\"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n                == 0` and `type` is `GRID`, `False` otherwise\n        \"\"\"\n        return (\n            self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n        ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n\n        Returns:\n            Hash of this instance.\n        \"\"\"\n        return hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: ComponentCategory\n</code></pre> <p>The category of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: ComponentMetadata | None = None\n</code></pre> <p>The metadata of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: ComponentType | None = None\n</code></pre> <p>The type of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Compute a hash of this instance, obtained by hashing the <code>component_id</code> field.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of this instance.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n\n    Returns:\n        Hash of this instance.\n    \"\"\"\n    return hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>id &gt; 0</code> and <code>type</code> is a valid <code>ComponentCategory</code>, or if <code>id == 0</code> and <code>type</code> is <code>GRID</code>, <code>False</code> otherwise</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n            == 0` and `type` is `GRID`, `False` otherwise\n    \"\"\"\n    return (\n        self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n    ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory","title":"frequenz.client.microgrid.ComponentCategory","text":"<p>               Bases: <code>Enum</code></p> <p>Possible types of microgrid component.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class ComponentCategory(Enum):\n    \"\"\"Possible types of microgrid component.\"\"\"\n\n    NONE = PbComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n    \"\"\"Unspecified component category.\"\"\"\n\n    GRID = PbComponentCategory.COMPONENT_CATEGORY_GRID\n    \"\"\"Grid component.\"\"\"\n\n    METER = PbComponentCategory.COMPONENT_CATEGORY_METER\n    \"\"\"Meter component.\"\"\"\n\n    INVERTER = PbComponentCategory.COMPONENT_CATEGORY_INVERTER\n    \"\"\"Inverter component.\"\"\"\n\n    BATTERY = PbComponentCategory.COMPONENT_CATEGORY_BATTERY\n    \"\"\"Battery component.\"\"\"\n\n    EV_CHARGER = PbComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n    \"\"\"EV charger component.\"\"\"\n\n    CHP = PbComponentCategory.COMPONENT_CATEGORY_CHP\n    \"\"\"CHP component.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = COMPONENT_CATEGORY_BATTERY\n</code></pre> <p>Battery component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.CHP","title":"CHP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHP = COMPONENT_CATEGORY_CHP\n</code></pre> <p>CHP component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.EV_CHARGER","title":"EV_CHARGER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_CHARGER = COMPONENT_CATEGORY_EV_CHARGER\n</code></pre> <p>EV charger component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.GRID","title":"GRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRID = COMPONENT_CATEGORY_GRID\n</code></pre> <p>Grid component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.INVERTER","title":"INVERTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVERTER = COMPONENT_CATEGORY_INVERTER\n</code></pre> <p>Inverter component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.METER","title":"METER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METER = COMPONENT_CATEGORY_METER\n</code></pre> <p>Meter component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = COMPONENT_CATEGORY_UNSPECIFIED\n</code></pre> <p>Unspecified component category.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData","title":"frequenz.client.microgrid.ComponentData  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A private base class for strongly typed component data classes.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentData(ABC):\n    \"\"\"A private base class for strongly typed component data classes.\"\"\"\n\n    component_id: int\n    \"\"\"The ID identifying this component in the microgrid.\"\"\"\n\n    timestamp: datetime\n    \"\"\"The timestamp of when the data was measured.\"\"\"\n\n    # The `raw` attribute is excluded from the constructor as it can only be provided\n    # when instantiating `ComponentData` using the `from_proto` method, which reads\n    # data from a protobuf message. The whole protobuf message is stored as the `raw`\n    # attribute. When `ComponentData` is not instantiated from a protobuf message,\n    # i.e. using the constructor, `raw` will be set to `None`.\n    raw: PbComponentData | None = field(default=None, init=False)\n    \"\"\"Raw component data as decoded from the wire.\"\"\"\n\n    def _set_raw(self, raw: PbComponentData) -&gt; None:\n        \"\"\"Store raw protobuf message.\n\n        It is preferred to keep the dataclasses immutable (frozen) and make the `raw`\n            attribute read-only, which is why the approach of writing to `__dict__`\n            was used, instead of mutating the `self.raw = raw` attribute directly.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n        \"\"\"\n        self.__dict__[\"raw\"] = raw\n\n    @classmethod\n    @abstractmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create ComponentData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            The instance created from the protobuf message.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.from_proto","title":"from_proto  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create ComponentData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The instance created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create ComponentData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        The instance created from the protobuf message.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetadata","title":"frequenz.client.microgrid.ComponentMetadata  <code>dataclass</code>","text":"<p>Base class for component metadata classes.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentMetadata:\n    \"\"\"Base class for component metadata classes.\"\"\"\n\n    fuse: Fuse | None = None\n    \"\"\"The fuse at the grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetadata.fuse","title":"fuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None = None\n</code></pre> <p>The fuse at the grid connection point.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId","title":"frequenz.client.microgrid.ComponentMetricId","text":"<p>               Bases: <code>Enum</code></p> <p>An enum representing the various metrics available in the microgrid.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class ComponentMetricId(Enum):\n    \"\"\"An enum representing the various metrics available in the microgrid.\"\"\"\n\n    ACTIVE_POWER = \"active_power\"\n    \"\"\"Active power.\"\"\"\n\n    ACTIVE_POWER_PHASE_1 = \"active_power_phase_1\"\n    \"\"\"Active power in phase 1.\"\"\"\n    ACTIVE_POWER_PHASE_2 = \"active_power_phase_2\"\n    \"\"\"Active power in phase 2.\"\"\"\n    ACTIVE_POWER_PHASE_3 = \"active_power_phase_3\"\n    \"\"\"Active power in phase 3.\"\"\"\n\n    REACTIVE_POWER = \"reactive_power\"\n    \"\"\"Reactive power.\"\"\"\n\n    REACTIVE_POWER_PHASE_1 = \"reactive_power_phase_1\"\n    \"\"\"Reactive power in phase 1.\"\"\"\n    REACTIVE_POWER_PHASE_2 = \"reactive_power_phase_2\"\n    \"\"\"Reactive power in phase 2.\"\"\"\n    REACTIVE_POWER_PHASE_3 = \"reactive_power_phase_3\"\n    \"\"\"Reactive power in phase 3.\"\"\"\n\n    CURRENT_PHASE_1 = \"current_phase_1\"\n    \"\"\"Current in phase 1.\"\"\"\n    CURRENT_PHASE_2 = \"current_phase_2\"\n    \"\"\"Current in phase 2.\"\"\"\n    CURRENT_PHASE_3 = \"current_phase_3\"\n    \"\"\"Current in phase 3.\"\"\"\n\n    VOLTAGE_PHASE_1 = \"voltage_phase_1\"\n    \"\"\"Voltage in phase 1.\"\"\"\n    VOLTAGE_PHASE_2 = \"voltage_phase_2\"\n    \"\"\"Voltage in phase 2.\"\"\"\n    VOLTAGE_PHASE_3 = \"voltage_phase_3\"\n    \"\"\"Voltage in phase 3.\"\"\"\n\n    FREQUENCY = \"frequency\"\n\n    SOC = \"soc\"\n    \"\"\"State of charge.\"\"\"\n    SOC_LOWER_BOUND = \"soc_lower_bound\"\n    \"\"\"Lower bound of state of charge.\"\"\"\n    SOC_UPPER_BOUND = \"soc_upper_bound\"\n    \"\"\"Upper bound of state of charge.\"\"\"\n    CAPACITY = \"capacity\"\n    \"\"\"Capacity.\"\"\"\n\n    POWER_INCLUSION_LOWER_BOUND = \"power_inclusion_lower_bound\"\n    \"\"\"Power inclusion lower bound.\"\"\"\n    POWER_EXCLUSION_LOWER_BOUND = \"power_exclusion_lower_bound\"\n    \"\"\"Power exclusion lower bound.\"\"\"\n    POWER_EXCLUSION_UPPER_BOUND = \"power_exclusion_upper_bound\"\n    \"\"\"Power exclusion upper bound.\"\"\"\n    POWER_INCLUSION_UPPER_BOUND = \"power_inclusion_upper_bound\"\n    \"\"\"Power inclusion upper bound.\"\"\"\n\n    ACTIVE_POWER_INCLUSION_LOWER_BOUND = \"active_power_inclusion_lower_bound\"\n    \"\"\"Active power inclusion lower bound.\"\"\"\n    ACTIVE_POWER_EXCLUSION_LOWER_BOUND = \"active_power_exclusion_lower_bound\"\n    \"\"\"Active power exclusion lower bound.\"\"\"\n    ACTIVE_POWER_EXCLUSION_UPPER_BOUND = \"active_power_exclusion_upper_bound\"\n    \"\"\"Active power exclusion upper bound.\"\"\"\n    ACTIVE_POWER_INCLUSION_UPPER_BOUND = \"active_power_inclusion_upper_bound\"\n    \"\"\"Active power inclusion upper bound.\"\"\"\n\n    TEMPERATURE = \"temperature\"\n    \"\"\"Temperature.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER","title":"ACTIVE_POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER = 'active_power'\n</code></pre> <p>Active power.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_EXCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_LOWER_BOUND = (\n    \"active_power_exclusion_lower_bound\"\n)\n</code></pre> <p>Active power exclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_EXCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_UPPER_BOUND = (\n    \"active_power_exclusion_upper_bound\"\n)\n</code></pre> <p>Active power exclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_INCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_LOWER_BOUND = (\n    \"active_power_inclusion_lower_bound\"\n)\n</code></pre> <p>Active power inclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_INCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_UPPER_BOUND = (\n    \"active_power_inclusion_upper_bound\"\n)\n</code></pre> <p>Active power inclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_PHASE_1","title":"ACTIVE_POWER_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_PHASE_1 = 'active_power_phase_1'\n</code></pre> <p>Active power in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_PHASE_2","title":"ACTIVE_POWER_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_PHASE_2 = 'active_power_phase_2'\n</code></pre> <p>Active power in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_PHASE_3","title":"ACTIVE_POWER_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_PHASE_3 = 'active_power_phase_3'\n</code></pre> <p>Active power in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CAPACITY","title":"CAPACITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPACITY = 'capacity'\n</code></pre> <p>Capacity.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CURRENT_PHASE_1","title":"CURRENT_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_1 = 'current_phase_1'\n</code></pre> <p>Current in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CURRENT_PHASE_2","title":"CURRENT_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_2 = 'current_phase_2'\n</code></pre> <p>Current in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CURRENT_PHASE_3","title":"CURRENT_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_3 = 'current_phase_3'\n</code></pre> <p>Current in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_EXCLUSION_LOWER_BOUND","title":"POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_LOWER_BOUND = 'power_exclusion_lower_bound'\n</code></pre> <p>Power exclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_EXCLUSION_UPPER_BOUND","title":"POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_UPPER_BOUND = 'power_exclusion_upper_bound'\n</code></pre> <p>Power exclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_INCLUSION_LOWER_BOUND","title":"POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_LOWER_BOUND = 'power_inclusion_lower_bound'\n</code></pre> <p>Power inclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_INCLUSION_UPPER_BOUND","title":"POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_UPPER_BOUND = 'power_inclusion_upper_bound'\n</code></pre> <p>Power inclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER","title":"REACTIVE_POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER = 'reactive_power'\n</code></pre> <p>Reactive power.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER_PHASE_1","title":"REACTIVE_POWER_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER_PHASE_1 = 'reactive_power_phase_1'\n</code></pre> <p>Reactive power in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER_PHASE_2","title":"REACTIVE_POWER_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER_PHASE_2 = 'reactive_power_phase_2'\n</code></pre> <p>Reactive power in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER_PHASE_3","title":"REACTIVE_POWER_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER_PHASE_3 = 'reactive_power_phase_3'\n</code></pre> <p>Reactive power in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.SOC","title":"SOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC = 'soc'\n</code></pre> <p>State of charge.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.SOC_LOWER_BOUND","title":"SOC_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_LOWER_BOUND = 'soc_lower_bound'\n</code></pre> <p>Lower bound of state of charge.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.SOC_UPPER_BOUND","title":"SOC_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_UPPER_BOUND = 'soc_upper_bound'\n</code></pre> <p>Upper bound of state of charge.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.TEMPERATURE","title":"TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPERATURE = 'temperature'\n</code></pre> <p>Temperature.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.VOLTAGE_PHASE_1","title":"VOLTAGE_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_1 = 'voltage_phase_1'\n</code></pre> <p>Voltage in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.VOLTAGE_PHASE_2","title":"VOLTAGE_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_2 = 'voltage_phase_2'\n</code></pre> <p>Voltage in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.VOLTAGE_PHASE_3","title":"VOLTAGE_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_3 = 'voltage_phase_3'\n</code></pre> <p>Voltage in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentType","title":"frequenz.client.microgrid.ComponentType","text":"<p>               Bases: <code>Enum</code></p> <p>A base class from which individual component types are derived.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class ComponentType(Enum):\n    \"\"\"A base class from which individual component types are derived.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection","title":"frequenz.client.microgrid.Connection  <code>dataclass</code>","text":"<p>Metadata for a connection between microgrid components.</p> Source code in <code>frequenz/client/microgrid/_connection.py</code> <pre><code>@dataclass(frozen=True)\nclass Connection:\n    \"\"\"Metadata for a connection between microgrid components.\"\"\"\n\n    start: int\n    \"\"\"The component ID that represents the start component of the connection.\"\"\"\n\n    end: int\n    \"\"\"The component ID that represents the end component of the connection.\"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n                otherwise.\n        \"\"\"\n        return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: int\n</code></pre> <p>The component ID that represents the end component of the connection.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: int\n</code></pre> <p>The component ID that represents the start component of the connection.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>start &gt;= 0</code>, <code>end &gt; 0</code>, and <code>start != end</code>, <code>False</code> otherwise.</p> Source code in <code>frequenz/client/microgrid/_connection.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n            otherwise.\n    \"\"\"\n    return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss","title":"frequenz.client.microgrid.DataLoss","text":"<p>               Bases: <code>GrpcError</code></p> <p>Unrecoverable data loss or corruption.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class DataLoss(GrpcError):\n    \"\"\"Unrecoverable data loss or corruption.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Unrecoverable data loss or corruption\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Unrecoverable data loss or corruption\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.DataLoss.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState","title":"frequenz.client.microgrid.EVChargerCableState","text":"<p>               Bases: <code>Enum</code></p> <p>Cable states of an EV Charger.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>class EVChargerCableState(Enum):\n    \"\"\"Cable states of an EV Charger.\"\"\"\n\n    UNSPECIFIED = PbEvCableState.CABLE_STATE_UNSPECIFIED\n    \"\"\"Unspecified cable state.\"\"\"\n\n    UNPLUGGED = PbEvCableState.CABLE_STATE_UNPLUGGED\n    \"\"\"The cable is unplugged.\"\"\"\n\n    CHARGING_STATION_PLUGGED = PbEvCableState.CABLE_STATE_CHARGING_STATION_PLUGGED\n    \"\"\"The cable is plugged into the charging station.\"\"\"\n\n    CHARGING_STATION_LOCKED = PbEvCableState.CABLE_STATE_CHARGING_STATION_LOCKED\n    \"\"\"The cable is plugged into the charging station and locked.\"\"\"\n\n    EV_PLUGGED = PbEvCableState.CABLE_STATE_EV_PLUGGED\n    \"\"\"The cable is plugged into the EV.\"\"\"\n\n    EV_LOCKED = PbEvCableState.CABLE_STATE_EV_LOCKED\n    \"\"\"The cable is plugged into the EV and locked.\"\"\"\n\n    @classmethod\n    def from_pb(cls, state: PbEvCableState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf state value to this enum.\n\n        Args:\n            state: The protobuf cable state to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(state)\n        except ValueError:\n            return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.CHARGING_STATION_LOCKED","title":"CHARGING_STATION_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_LOCKED = (\n    CABLE_STATE_CHARGING_STATION_LOCKED\n)\n</code></pre> <p>The cable is plugged into the charging station and locked.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.CHARGING_STATION_PLUGGED","title":"CHARGING_STATION_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_PLUGGED = (\n    CABLE_STATE_CHARGING_STATION_PLUGGED\n)\n</code></pre> <p>The cable is plugged into the charging station.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.EV_LOCKED","title":"EV_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_LOCKED = CABLE_STATE_EV_LOCKED\n</code></pre> <p>The cable is plugged into the EV and locked.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.EV_PLUGGED","title":"EV_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_PLUGGED = CABLE_STATE_EV_PLUGGED\n</code></pre> <p>The cable is plugged into the EV.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.UNPLUGGED","title":"UNPLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNPLUGGED = CABLE_STATE_UNPLUGGED\n</code></pre> <p>The cable is unplugged.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = CABLE_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified cable state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf state value to this enum.</p> PARAMETER DESCRIPTION <code>state</code> <p>The protobuf cable state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(cls, state: PbEvCableState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf state value to this enum.\n\n    Args:\n        state: The protobuf cable state to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(state)\n    except ValueError:\n        return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState","title":"frequenz.client.microgrid.EVChargerComponentState","text":"<p>               Bases: <code>Enum</code></p> <p>Component State of an EV Charger.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>class EVChargerComponentState(Enum):\n    \"\"\"Component State of an EV Charger.\"\"\"\n\n    UNSPECIFIED = PbEvComponentState.COMPONENT_STATE_UNSPECIFIED\n    \"\"\"Unspecified component state.\"\"\"\n\n    STARTING = PbEvComponentState.COMPONENT_STATE_STARTING\n    \"\"\"The component is starting.\"\"\"\n\n    NOT_READY = PbEvComponentState.COMPONENT_STATE_NOT_READY\n    \"\"\"The component is not ready.\"\"\"\n\n    READY = PbEvComponentState.COMPONENT_STATE_READY\n    \"\"\"The component is ready.\"\"\"\n\n    CHARGING = PbEvComponentState.COMPONENT_STATE_CHARGING\n    \"\"\"The component is charging.\"\"\"\n\n    DISCHARGING = PbEvComponentState.COMPONENT_STATE_DISCHARGING\n    \"\"\"The component is discharging.\"\"\"\n\n    ERROR = PbEvComponentState.COMPONENT_STATE_ERROR\n    \"\"\"The component is in error state.\"\"\"\n\n    AUTHORIZATION_REJECTED = PbEvComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED\n    \"\"\"The component rejected authorization.\"\"\"\n\n    INTERRUPTED = PbEvComponentState.COMPONENT_STATE_INTERRUPTED\n    \"\"\"The component is interrupted.\"\"\"\n\n    UNKNOWN = PbEvComponentState.COMPONENT_STATE_UNKNOWN\n    \"\"\"A state is provided by the component, but it is not one of the above states.\"\"\"\n\n    @classmethod\n    def from_pb(cls, state: PbEvComponentState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf state value to this enum.\n\n        Args:\n            state: The protobuf component state to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(state)\n        except ValueError:\n            return cls(cls.UNKNOWN)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.AUTHORIZATION_REJECTED","title":"AUTHORIZATION_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTHORIZATION_REJECTED = (\n    COMPONENT_STATE_AUTHORIZATION_REJECTED\n)\n</code></pre> <p>The component rejected authorization.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.CHARGING","title":"CHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING = COMPONENT_STATE_CHARGING\n</code></pre> <p>The component is charging.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.DISCHARGING","title":"DISCHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCHARGING = COMPONENT_STATE_DISCHARGING\n</code></pre> <p>The component is discharging.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = COMPONENT_STATE_ERROR\n</code></pre> <p>The component is in error state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.INTERRUPTED","title":"INTERRUPTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERRUPTED = COMPONENT_STATE_INTERRUPTED\n</code></pre> <p>The component is interrupted.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.NOT_READY","title":"NOT_READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_READY = COMPONENT_STATE_NOT_READY\n</code></pre> <p>The component is not ready.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.READY","title":"READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>READY = COMPONENT_STATE_READY\n</code></pre> <p>The component is ready.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.STARTING","title":"STARTING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STARTING = COMPONENT_STATE_STARTING\n</code></pre> <p>The component is starting.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = COMPONENT_STATE_UNKNOWN\n</code></pre> <p>A state is provided by the component, but it is not one of the above states.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = COMPONENT_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified component state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf state value to this enum.</p> PARAMETER DESCRIPTION <code>state</code> <p>The protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(cls, state: PbEvComponentState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf state value to this enum.\n\n    Args:\n        state: The protobuf component state to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(state)\n    except ValueError:\n        return cls(cls.UNKNOWN)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData","title":"frequenz.client.microgrid.EVChargerData  <code>dataclass</code>","text":"<p>               Bases: <code>ComponentData</code></p> <p>A wrapper class for holding ev_charger data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData(ComponentData):  # pylint: disable=too-many-instance-attributes\n    \"\"\"A wrapper class for holding ev_charger data.\"\"\"\n\n    active_power: float\n    \"\"\"The total active 3-phase AC power, in Watts (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    active_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    reactive_power: float\n    \"\"\"The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    reactive_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).\n\n    The provided values are for phase 1, 2, and 3 respectively.\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The AC voltage in Volts (V) between the line and the neutral\n        wire for phase/line 1,2 and 3 respectively.\n    \"\"\"\n\n    active_power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for EV charger power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for EV charger power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for EV charger power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for EV charger power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    frequency: float\n    \"\"\"AC frequency, in Hertz (Hz).\"\"\"\n\n    cable_state: EVChargerCableState\n    \"\"\"The state of the ev charger's cable.\"\"\"\n\n    component_state: EVChargerComponentState\n    \"\"\"The state of the ev charger.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create EVChargerData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of EVChargerData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.ev_charger.data.ac.power_active\n        ev_charger_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw_power.value,\n            active_power_per_phase=(\n                raw.ev_charger.data.ac.phase_1.power_active.value,\n                raw.ev_charger.data.ac.phase_2.power_active.value,\n                raw.ev_charger.data.ac.phase_3.power_active.value,\n            ),\n            reactive_power=raw.ev_charger.data.ac.power_reactive.value,\n            reactive_power_per_phase=(\n                raw.ev_charger.data.ac.phase_1.power_reactive.value,\n                raw.ev_charger.data.ac.phase_2.power_reactive.value,\n                raw.ev_charger.data.ac.phase_3.power_reactive.value,\n            ),\n            current_per_phase=(\n                raw.ev_charger.data.ac.phase_1.current.value,\n                raw.ev_charger.data.ac.phase_2.current.value,\n                raw.ev_charger.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.ev_charger.data.ac.phase_1.voltage.value,\n                raw.ev_charger.data.ac.phase_2.voltage.value,\n                raw.ev_charger.data.ac.phase_3.voltage.value,\n            ),\n            active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n            component_state=EVChargerComponentState.from_pb(\n                raw.ev_charger.state.component_state\n            ),\n            frequency=raw.ev_charger.data.ac.frequency.value,\n        )\n        ev_charger_data._set_raw(raw=raw)\n        return ev_charger_data\n\n    def is_ev_connected(self) -&gt; bool:\n        \"\"\"Check whether an EV is connected to the charger.\n\n        Returns:\n            When the charger is not in an error state, whether an EV is connected to\n                the charger.\n        \"\"\"\n        return self.component_state not in (\n            EVChargerComponentState.AUTHORIZATION_REJECTED,\n            EVChargerComponentState.ERROR,\n        ) and self.cable_state in (\n            EVChargerCableState.EV_LOCKED,\n            EVChargerCableState.EV_PLUGGED,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The total active 3-phase AC power, in Watts (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_exclusion_lower_bound","title":"active_power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for EV charger power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_exclusion_upper_bound","title":"active_power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for EV charger power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_inclusion_lower_bound","title":"active_power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for EV charger power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_inclusion_upper_bound","title":"active_power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for EV charger power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_per_phase","title":"active_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>active_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.cable_state","title":"cable_state  <code>instance-attribute</code>","text":"<pre><code>cable_state: EVChargerCableState\n</code></pre> <p>The state of the ev charger's cable.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.component_state","title":"component_state  <code>instance-attribute</code>","text":"<pre><code>component_state: EVChargerComponentState\n</code></pre> <p>The state of the ev charger.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively.</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.reactive_power","title":"reactive_power  <code>instance-attribute</code>","text":"<pre><code>reactive_power: float\n</code></pre> <p>The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.reactive_power_per_phase","title":"reactive_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>reactive_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).</p> <p>The provided values are for phase 1, 2, and 3 respectively.</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create EVChargerData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of EVChargerData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create EVChargerData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of EVChargerData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.ev_charger.data.ac.power_active\n    ev_charger_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw_power.value,\n        active_power_per_phase=(\n            raw.ev_charger.data.ac.phase_1.power_active.value,\n            raw.ev_charger.data.ac.phase_2.power_active.value,\n            raw.ev_charger.data.ac.phase_3.power_active.value,\n        ),\n        reactive_power=raw.ev_charger.data.ac.power_reactive.value,\n        reactive_power_per_phase=(\n            raw.ev_charger.data.ac.phase_1.power_reactive.value,\n            raw.ev_charger.data.ac.phase_2.power_reactive.value,\n            raw.ev_charger.data.ac.phase_3.power_reactive.value,\n        ),\n        current_per_phase=(\n            raw.ev_charger.data.ac.phase_1.current.value,\n            raw.ev_charger.data.ac.phase_2.current.value,\n            raw.ev_charger.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.ev_charger.data.ac.phase_1.voltage.value,\n            raw.ev_charger.data.ac.phase_2.voltage.value,\n            raw.ev_charger.data.ac.phase_3.voltage.value,\n        ),\n        active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n        component_state=EVChargerComponentState.from_pb(\n            raw.ev_charger.state.component_state\n        ),\n        frequency=raw.ev_charger.data.ac.frequency.value,\n    )\n    ev_charger_data._set_raw(raw=raw)\n    return ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.is_ev_connected","title":"is_ev_connected","text":"<pre><code>is_ev_connected() -&gt; bool\n</code></pre> <p>Check whether an EV is connected to the charger.</p> RETURNS DESCRIPTION <code>bool</code> <p>When the charger is not in an error state, whether an EV is connected to the charger.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>def is_ev_connected(self) -&gt; bool:\n    \"\"\"Check whether an EV is connected to the charger.\n\n    Returns:\n        When the charger is not in an error state, whether an EV is connected to\n            the charger.\n    \"\"\"\n    return self.component_state not in (\n        EVChargerComponentState.AUTHORIZATION_REJECTED,\n        EVChargerComponentState.ERROR,\n    ) and self.cable_state in (\n        EVChargerCableState.EV_LOCKED,\n        EVChargerCableState.EV_PLUGGED,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists","title":"frequenz.client.microgrid.EntityAlreadyExists","text":"<p>               Bases: <code>GrpcError</code></p> <p>The entity that we attempted to create already exists.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class EntityAlreadyExists(GrpcError):\n    \"\"\"The entity that we attempted to create already exists.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The entity that we attempted to create already exists\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the entity is deleted later it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The entity that we attempted to create already exists\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the entity is deleted later it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityAlreadyExists.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound","title":"frequenz.client.microgrid.EntityNotFound","text":"<p>               Bases: <code>GrpcError</code></p> <p>The requested entity was not found.</p> <p>Note that this error differs from PermissionDenied. This error is used when the requested entity is not found, regardless of the user's permissions.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class EntityNotFound(GrpcError):\n    \"\"\"The requested entity was not found.\n\n    Note that this error differs from\n    [PermissionDenied][frequenz.client.base.exception.PermissionDenied]. This error is\n    used when the requested entity is not found, regardless of the user's permissions.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The requested entity was not found\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the entity is added later it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The requested entity was not found\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the entity is added later it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EntityNotFound.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ErrorLevel","title":"frequenz.client.microgrid.ErrorLevel","text":"<p>               Bases: <code>Enum</code></p> <p>Error level.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>class ErrorLevel(Enum):\n    \"\"\"Error level.\"\"\"\n\n    UNSPECIFIED = PbErrorLevel.ERROR_LEVEL_UNSPECIFIED\n    \"\"\"Unspecified component error.\"\"\"\n\n    WARN = PbErrorLevel.ERROR_LEVEL_WARN\n    \"\"\"Action must be taken to prevent a severe error from occurring in the future.\"\"\"\n\n    CRITICAL = PbErrorLevel.ERROR_LEVEL_CRITICAL\n    \"\"\"A severe error that causes the component to fail. Immediate action must be taken.\"\"\"\n\n    @classmethod\n    def from_pb(cls, code: PbErrorLevel.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf error level value to this enum.\n\n        Args:\n            code: The protobuf error level to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(code)\n        except ValueError:\n            return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ErrorLevel-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ErrorLevel.CRITICAL","title":"CRITICAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CRITICAL = ERROR_LEVEL_CRITICAL\n</code></pre> <p>A severe error that causes the component to fail. Immediate action must be taken.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ErrorLevel.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ERROR_LEVEL_UNSPECIFIED\n</code></pre> <p>Unspecified component error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ErrorLevel.WARN","title":"WARN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WARN = ERROR_LEVEL_WARN\n</code></pre> <p>Action must be taken to prevent a severe error from occurring in the future.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ErrorLevel-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ErrorLevel.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(code: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf error level value to this enum.</p> PARAMETER DESCRIPTION <code>code</code> <p>The protobuf error level to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>@classmethod\ndef from_pb(cls, code: PbErrorLevel.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf error level value to this enum.\n\n    Args:\n        code: The protobuf error level to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(code)\n    except ValueError:\n        return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Fuse","title":"frequenz.client.microgrid.Fuse  <code>dataclass</code>","text":"<p>Fuse data class.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Fuse:\n    \"\"\"Fuse data class.\"\"\"\n\n    max_current: float\n    \"\"\"Rated current of the fuse.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Fuse-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Fuse.max_current","title":"max_current  <code>instance-attribute</code>","text":"<pre><code>max_current: float\n</code></pre> <p>Rated current of the fuse.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GridMetadata","title":"frequenz.client.microgrid.GridMetadata  <code>dataclass</code>","text":"<p>               Bases: <code>ComponentMetadata</code></p> <p>Metadata for a grid connection point.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass GridMetadata(ComponentMetadata):\n    \"\"\"Metadata for a grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GridMetadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GridMetadata.fuse","title":"fuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None = None\n</code></pre> <p>The fuse at the grid connection point.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError","title":"frequenz.client.microgrid.GrpcError","text":"<p>               Bases: <code>ApiClientError</code></p> <p>The gRPC server returned an error with a status code.</p> <p>These errors are specific to gRPC. If you want to use the client in a protocol-independent way, you should avoid catching this exception. Catching subclasses that don't have grpc in their name should be protocol-independent.</p> <p>The following sub-classes are available:</p> <ul> <li>DataLoss: Unrecoverable data loss or   corruption.</li> <li>EntityAlreadyExists: The   entity that we attempted to create already exists.</li> <li>EntityNotFound: The requested   entity was not found.</li> <li>InternalError: Some invariants   expected by the underlying system have been broken.</li> <li>InvalidArgument: The client   specified an invalid argument.</li> <li>OperationAborted: The   operation was aborted.</li> <li>OperationCancelled: The   operation was cancelled.</li> <li>OperationNotImplemented:   The operation is not implemented or not supported/enabled in this service.</li> <li>OperationOutOfRange: The   operation was attempted past the valid range.</li> <li>OperationPreconditionFailed:   The operation was rejected because the system is not in a required state.</li> <li>OperationTimedOut: The time   limit was exceeded while waiting for the operation to complete.</li> <li>OperationUnauthenticated:   The request does not have valid authentication credentials for the operation.</li> <li>PermissionDenied: The caller   does not have permission to execute the specified operation.</li> <li>ResourceExhausted: Some   resource has been exhausted (for example per-user quota, disk space, etc.).</li> <li>ServiceUnavailable: The   service is currently unavailable.</li> <li>UnknownError: There was an error   that can't be described using other statuses.</li> <li>UnrecognizedGrpcStatus:   The gRPC server returned an unrecognized status code.</li> </ul> References <ul> <li>gRPC status    codes</li> </ul> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class GrpcError(ApiClientError):\n    \"\"\"The gRPC server returned an error with a status code.\n\n    These errors are specific to gRPC. If you want to use the client in\n    a protocol-independent way, you should avoid catching this exception. Catching\n    subclasses that don't have *grpc* in their name should be protocol-independent.\n\n    The following sub-classes are available:\n\n    - [DataLoss][frequenz.client.base.exception.DataLoss]: Unrecoverable data loss or\n      corruption.\n    - [EntityAlreadyExists][frequenz.client.base.exception.EntityAlreadyExists]: The\n      entity that we attempted to create already exists.\n    - [EntityNotFound][frequenz.client.base.exception.EntityNotFound]: The requested\n      entity was not found.\n    - [InternalError][frequenz.client.base.exception.InternalError]: Some invariants\n      expected by the underlying system have been broken.\n    - [InvalidArgument][frequenz.client.base.exception.InvalidArgument]: The client\n      specified an invalid argument.\n    - [OperationAborted][frequenz.client.base.exception.OperationAborted]: The\n      operation was aborted.\n    - [OperationCancelled][frequenz.client.base.exception.OperationCancelled]: The\n      operation was cancelled.\n    - [OperationNotImplemented][frequenz.client.base.exception.OperationNotImplemented]:\n      The operation is not implemented or not supported/enabled in this service.\n    - [OperationOutOfRange][frequenz.client.base.exception.OperationOutOfRange]: The\n      operation was attempted past the valid range.\n    - [OperationPreconditionFailed][frequenz.client.base.exception.OperationPreconditionFailed]:\n      The operation was rejected because the system is not in a required state.\n    - [OperationTimedOut][frequenz.client.base.exception.OperationTimedOut]: The time\n      limit was exceeded while waiting for the operation to complete.\n    - [OperationUnauthenticated][frequenz.client.base.exception.OperationUnauthenticated]:\n      The request does not have valid authentication credentials for the operation.\n    - [PermissionDenied][frequenz.client.base.exception.PermissionDenied]: The caller\n      does not have permission to execute the specified operation.\n    - [ResourceExhausted][frequenz.client.base.exception.ResourceExhausted]: Some\n      resource has been exhausted (for example per-user quota, disk space, etc.).\n    - [ServiceUnavailable][frequenz.client.base.exception.ServiceUnavailable]: The\n      service is currently unavailable.\n    - [UnknownError][frequenz.client.base.exception.UnknownError]: There was an error\n      that can't be described using other statuses.\n    - [UnrecognizedGrpcStatus][frequenz.client.base.exception.UnrecognizedGrpcStatus]:\n      The gRPC server returned an unrecognized status code.\n\n    References:\n        * [gRPC status\n           codes](https://github.com/grpc/grpc/blob/master/doc/statuscodes.md)\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        *,\n        server_url: str,\n        operation: str,\n        description: str,\n        grpc_error: AioRpcError,\n        retryable: bool,\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            description: A human-readable description of the error.\n            grpc_error: The gRPC error originating this exception.\n            retryable: Whether retrying the operation might succeed.\n        \"\"\"\n        status_name = grpc_error.code().name\n        message = grpc_error.details()\n        details = grpc_error.debug_error_string()\n        message = f\": {message}\" if message else \"\"\n        details = f\" ({details})\" if details else \"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=f\"{description} &lt;status={status_name}&gt;{message}{details}\",\n            retryable=retryable,\n        )\n        self.description: str = description\n        \"\"\"The human-readable description of the error.\"\"\"\n\n        self.grpc_error: AioRpcError = grpc_error\n        \"\"\"The original gRPC error.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    grpc_error: AioRpcError,\n    retryable: bool\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>A human-readable description of the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> <code>retryable</code> <p>Whether retrying the operation might succeed.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    *,\n    server_url: str,\n    operation: str,\n    description: str,\n    grpc_error: AioRpcError,\n    retryable: bool,\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        description: A human-readable description of the error.\n        grpc_error: The gRPC error originating this exception.\n        retryable: Whether retrying the operation might succeed.\n    \"\"\"\n    status_name = grpc_error.code().name\n    message = grpc_error.details()\n    details = grpc_error.debug_error_string()\n    message = f\": {message}\" if message else \"\"\n    details = f\" ({details})\" if details else \"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=f\"{description} &lt;status={status_name}&gt;{message}{details}\",\n        retryable=retryable,\n    )\n    self.description: str = description\n    \"\"\"The human-readable description of the error.\"\"\"\n\n    self.grpc_error: AioRpcError = grpc_error\n    \"\"\"The original gRPC error.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GrpcError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError","title":"frequenz.client.microgrid.InternalError","text":"<p>               Bases: <code>GrpcError</code></p> <p>Some invariants expected by the underlying system have been broken.</p> <p>This error code is reserved for serious errors.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class InternalError(GrpcError):\n    \"\"\"Some invariants expected by the underlying system have been broken.\n\n    This error code is reserved for serious errors.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Some invariants expected by the underlying system have been \"\n            \"broken\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the system state changes it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Some invariants expected by the underlying system have been \"\n        \"broken\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the system state changes it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InternalError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument","title":"frequenz.client.microgrid.InvalidArgument","text":"<p>               Bases: <code>GrpcError</code>, <code>ValueError</code></p> <p>The client specified an invalid argument.</p> <p>Note that this error differs from OperationPreconditionFailed. This error indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name).</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class InvalidArgument(GrpcError, ValueError):\n    \"\"\"The client specified an invalid argument.\n\n    Note that this error differs from\n    [OperationPreconditionFailed][frequenz.client.base.exception.OperationPreconditionFailed].\n    This error indicates arguments that are problematic regardless of the state of the\n    system (e.g., a malformed file name).\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The client specified an invalid argument\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The client specified an invalid argument\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InvalidArgument.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState","title":"frequenz.client.microgrid.InverterComponentState","text":"<p>               Bases: <code>Enum</code></p> <p>Component states of an inverter.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>class InverterComponentState(Enum):\n    \"\"\"Component states of an inverter.\"\"\"\n\n    UNSPECIFIED = PbInverterComponentState.COMPONENT_STATE_UNSPECIFIED\n    \"\"\"Unspecified component state.\"\"\"\n\n    OFF = PbInverterComponentState.COMPONENT_STATE_OFF\n    \"\"\"Inverter is switched off.\"\"\"\n\n    SWITCHING_ON = PbInverterComponentState.COMPONENT_STATE_SWITCHING_ON\n    \"\"\"The PbInverteris starting up and needs some time to become fully operational.\"\"\"\n\n    SWITCHING_OFF = PbInverterComponentState.COMPONENT_STATE_SWITCHING_OFF\n    \"\"\"The PbInverteris switching off and needs some time to fully shut down.\"\"\"\n\n    STANDBY = PbInverterComponentState.COMPONENT_STATE_STANDBY\n    \"\"\"The PbInverteris in a standby state, and is disconnected from the grid.\n\n    When connected to the grid, it run a few tests, and move to the `IDLE` state.\n    \"\"\"\n\n    IDLE = PbInverterComponentState.COMPONENT_STATE_IDLE\n    \"\"\"The inverter is idle.\"\"\"\n\n    CHARGING = PbInverterComponentState.COMPONENT_STATE_CHARGING\n    \"\"\"The inverter is consuming electrical energy to charge batteries.\n\n    Applicable to `BATTERY` and `HYBRID` inverters only.\n    \"\"\"\n\n    DISCHARGING = PbInverterComponentState.COMPONENT_STATE_DISCHARGING\n    \"\"\"The inverter is generating electrical energy.\"\"\"\n\n    ERROR = PbInverterComponentState.COMPONENT_STATE_ERROR\n    \"\"\"The inverter is in a faulty state.\"\"\"\n\n    UNAVAILABLE = PbInverterComponentState.COMPONENT_STATE_UNAVAILABLE\n    \"\"\"The inverter is online, but currently unavailable.\n\n    Possibly due to a pre- scheduled maintenance.\n    \"\"\"\n\n    UNKNOWN = PbInverterComponentState.COMPONENT_STATE_UNKNOWN\n    \"\"\"A state is provided by the component, but it is not one of the above states.\"\"\"\n\n    @classmethod\n    def from_pb(cls, state: PbInverterComponentState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf state value to this enum.\n\n        Args:\n            state: The protobuf component state to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(state)\n        except ValueError:\n            return cls(cls.UNKNOWN)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.CHARGING","title":"CHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING = COMPONENT_STATE_CHARGING\n</code></pre> <p>The inverter is consuming electrical energy to charge batteries.</p> <p>Applicable to <code>BATTERY</code> and <code>HYBRID</code> inverters only.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.DISCHARGING","title":"DISCHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCHARGING = COMPONENT_STATE_DISCHARGING\n</code></pre> <p>The inverter is generating electrical energy.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = COMPONENT_STATE_ERROR\n</code></pre> <p>The inverter is in a faulty state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.IDLE","title":"IDLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE = COMPONENT_STATE_IDLE\n</code></pre> <p>The inverter is idle.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.OFF","title":"OFF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFF = COMPONENT_STATE_OFF\n</code></pre> <p>Inverter is switched off.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.STANDBY","title":"STANDBY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STANDBY = COMPONENT_STATE_STANDBY\n</code></pre> <p>The PbInverteris in a standby state, and is disconnected from the grid.</p> <p>When connected to the grid, it run a few tests, and move to the <code>IDLE</code> state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.SWITCHING_OFF","title":"SWITCHING_OFF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SWITCHING_OFF = COMPONENT_STATE_SWITCHING_OFF\n</code></pre> <p>The PbInverteris switching off and needs some time to fully shut down.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.SWITCHING_ON","title":"SWITCHING_ON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SWITCHING_ON = COMPONENT_STATE_SWITCHING_ON\n</code></pre> <p>The PbInverteris starting up and needs some time to become fully operational.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.UNAVAILABLE","title":"UNAVAILABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNAVAILABLE = COMPONENT_STATE_UNAVAILABLE\n</code></pre> <p>The inverter is online, but currently unavailable.</p> <p>Possibly due to a pre- scheduled maintenance.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = COMPONENT_STATE_UNKNOWN\n</code></pre> <p>A state is provided by the component, but it is not one of the above states.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = COMPONENT_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified component state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterComponentState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf state value to this enum.</p> PARAMETER DESCRIPTION <code>state</code> <p>The protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(cls, state: PbInverterComponentState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf state value to this enum.\n\n    Args:\n        state: The protobuf component state to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(state)\n    except ValueError:\n        return cls(cls.UNKNOWN)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData","title":"frequenz.client.microgrid.InverterData  <code>dataclass</code>","text":"<p>               Bases: <code>ComponentData</code></p> <p>A wrapper class for holding inverter data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass InverterData(ComponentData):  # pylint: disable=too-many-instance-attributes\n    \"\"\"A wrapper class for holding inverter data.\"\"\"\n\n    active_power: float\n    \"\"\"The total active 3-phase AC power, in Watts (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    active_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    reactive_power: float\n    \"\"\"The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    reactive_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).\n\n    The provided values are for phase 1, 2, and 3 respectively.\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1, 2 and 3 respectively.\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The AC voltage in Volts (V) between the line and the neutral wire for\n       phase/line 1, 2 and 3 respectively.\n    \"\"\"\n\n    active_power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for inverter power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for inverter power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for inverter power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for inverter power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    frequency: float\n    \"\"\"AC frequency, in Hertz (Hz).\"\"\"\n\n    component_state: InverterComponentState\n    \"\"\"State of the inverter.\"\"\"\n\n    errors: list[InverterError]\n    \"\"\"List of errors from the component.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create InverterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of InverterData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.inverter.data.ac.power_active\n        inverter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.inverter.data.ac.power_active.value,\n            active_power_per_phase=(\n                raw.inverter.data.ac.phase_1.power_active.value,\n                raw.inverter.data.ac.phase_2.power_active.value,\n                raw.inverter.data.ac.phase_3.power_active.value,\n            ),\n            reactive_power=raw.inverter.data.ac.power_reactive.value,\n            reactive_power_per_phase=(\n                raw.inverter.data.ac.phase_1.power_reactive.value,\n                raw.inverter.data.ac.phase_2.power_reactive.value,\n                raw.inverter.data.ac.phase_3.power_reactive.value,\n            ),\n            current_per_phase=(\n                raw.inverter.data.ac.phase_1.current.value,\n                raw.inverter.data.ac.phase_2.current.value,\n                raw.inverter.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.inverter.data.ac.phase_1.voltage.value,\n                raw.inverter.data.ac.phase_2.voltage.value,\n                raw.inverter.data.ac.phase_3.voltage.value,\n            ),\n            active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            frequency=raw.inverter.data.ac.frequency.value,\n            component_state=InverterComponentState.from_pb(\n                raw.inverter.state.component_state\n            ),\n            errors=[InverterError.from_pb(e) for e in raw.inverter.errors],\n        )\n\n        inverter_data._set_raw(raw=raw)\n        return inverter_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The total active 3-phase AC power, in Watts (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_exclusion_lower_bound","title":"active_power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_exclusion_upper_bound","title":"active_power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_inclusion_lower_bound","title":"active_power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_inclusion_upper_bound","title":"active_power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_per_phase","title":"active_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>active_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.component_state","title":"component_state  <code>instance-attribute</code>","text":"<pre><code>component_state: InverterComponentState\n</code></pre> <p>State of the inverter.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1, 2 and 3 respectively.</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: list[InverterError]\n</code></pre> <p>List of errors from the component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.reactive_power","title":"reactive_power  <code>instance-attribute</code>","text":"<pre><code>reactive_power: float\n</code></pre> <p>The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.reactive_power_per_phase","title":"reactive_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>reactive_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).</p> <p>The provided values are for phase 1, 2, and 3 respectively.</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1, 2 and 3 respectively.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create InverterData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of InverterData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create InverterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of InverterData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.inverter.data.ac.power_active\n    inverter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.inverter.data.ac.power_active.value,\n        active_power_per_phase=(\n            raw.inverter.data.ac.phase_1.power_active.value,\n            raw.inverter.data.ac.phase_2.power_active.value,\n            raw.inverter.data.ac.phase_3.power_active.value,\n        ),\n        reactive_power=raw.inverter.data.ac.power_reactive.value,\n        reactive_power_per_phase=(\n            raw.inverter.data.ac.phase_1.power_reactive.value,\n            raw.inverter.data.ac.phase_2.power_reactive.value,\n            raw.inverter.data.ac.phase_3.power_reactive.value,\n        ),\n        current_per_phase=(\n            raw.inverter.data.ac.phase_1.current.value,\n            raw.inverter.data.ac.phase_2.current.value,\n            raw.inverter.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.inverter.data.ac.phase_1.voltage.value,\n            raw.inverter.data.ac.phase_2.voltage.value,\n            raw.inverter.data.ac.phase_3.voltage.value,\n        ),\n        active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        frequency=raw.inverter.data.ac.frequency.value,\n        component_state=InverterComponentState.from_pb(\n            raw.inverter.state.component_state\n        ),\n        errors=[InverterError.from_pb(e) for e in raw.inverter.errors],\n    )\n\n    inverter_data._set_raw(raw=raw)\n    return inverter_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterError","title":"frequenz.client.microgrid.InverterError  <code>dataclass</code>","text":"<p>An inverter error.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass InverterError:\n    \"\"\"An inverter error.\"\"\"\n\n    code: InverterErrorCode = InverterErrorCode.UNSPECIFIED\n    \"\"\"The error code.\"\"\"\n\n    level: ErrorLevel = ErrorLevel.UNSPECIFIED\n    \"\"\"The error level.\"\"\"\n\n    message: str = \"\"\n    \"\"\"The error message.\"\"\"\n\n    @classmethod\n    def from_pb(cls, raw: PbInverterError) -&gt; Self:\n        \"\"\"Create a new instance using a protobuf message to get the values.\n\n        Args:\n            raw: The protobuf message to get the values from.\n\n        Returns:\n            The new instance with the values from the protobuf message.\n        \"\"\"\n        return cls(\n            code=InverterErrorCode.from_pb(raw.code),\n            level=ErrorLevel.from_pb(raw.level),\n            message=raw.msg,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterError.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: InverterErrorCode = UNSPECIFIED\n</code></pre> <p>The error code.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterError.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: ErrorLevel = UNSPECIFIED\n</code></pre> <p>The error level.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = ''\n</code></pre> <p>The error message.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterError.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(raw: Error) -&gt; Self\n</code></pre> <p>Create a new instance using a protobuf message to get the values.</p> PARAMETER DESCRIPTION <code>raw</code> <p>The protobuf message to get the values from.</p> <p> TYPE: <code>Error</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The new instance with the values from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>@classmethod\ndef from_pb(cls, raw: PbInverterError) -&gt; Self:\n    \"\"\"Create a new instance using a protobuf message to get the values.\n\n    Args:\n        raw: The protobuf message to get the values from.\n\n    Returns:\n        The new instance with the values from the protobuf message.\n    \"\"\"\n    return cls(\n        code=InverterErrorCode.from_pb(raw.code),\n        level=ErrorLevel.from_pb(raw.level),\n        message=raw.msg,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterErrorCode","title":"frequenz.client.microgrid.InverterErrorCode","text":"<p>               Bases: <code>Enum</code></p> <p>Inverter error code.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>class InverterErrorCode(Enum):\n    \"\"\"Inverter error code.\"\"\"\n\n    UNSPECIFIED = PbInverterErrorCode.ERROR_CODE_UNSPECIFIED\n    \"\"\"Unspecified inverter error code.\"\"\"\n\n    @classmethod\n    def from_pb(cls, code: PbInverterErrorCode.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf error code value to this enum.\n\n        Args:\n            code: The protobuf error code to convert.\n\n        Returns:\n            The enum value corresponding to the protobuf message.\n        \"\"\"\n        try:\n            return cls(code)\n        except ValueError:\n            return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterErrorCode-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterErrorCode.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ERROR_CODE_UNSPECIFIED\n</code></pre> <p>Unspecified inverter error code.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterErrorCode-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterErrorCode.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(code: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf error code value to this enum.</p> PARAMETER DESCRIPTION <code>code</code> <p>The protobuf error code to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_error.py</code> <pre><code>@classmethod\ndef from_pb(cls, code: PbInverterErrorCode.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf error code value to this enum.\n\n    Args:\n        code: The protobuf error code to convert.\n\n    Returns:\n        The enum value corresponding to the protobuf message.\n    \"\"\"\n    try:\n        return cls(code)\n    except ValueError:\n        return cls(cls.UNSPECIFIED)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType","title":"frequenz.client.microgrid.InverterType","text":"<p>               Bases: <code>ComponentType</code></p> <p>Enum representing inverter types.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class InverterType(ComponentType):\n    \"\"\"Enum representing inverter types.\"\"\"\n\n    NONE = PbInverterType.TYPE_UNSPECIFIED\n    \"\"\"Unspecified inverter type.\"\"\"\n\n    BATTERY = PbInverterType.TYPE_BATTERY\n    \"\"\"Battery inverter.\"\"\"\n\n    SOLAR = PbInverterType.TYPE_SOLAR\n    \"\"\"Solar inverter.\"\"\"\n\n    HYBRID = PbInverterType.TYPE_HYBRID\n    \"\"\"Hybrid inverter.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = TYPE_BATTERY\n</code></pre> <p>Battery inverter.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.HYBRID","title":"HYBRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYBRID = TYPE_HYBRID\n</code></pre> <p>Hybrid inverter.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified inverter type.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.SOLAR","title":"SOLAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOLAR = TYPE_SOLAR\n</code></pre> <p>Solar inverter.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location","title":"frequenz.client.microgrid.Location  <code>dataclass</code>","text":"<p>Metadata for the location of microgrid.</p> Source code in <code>frequenz/client/microgrid/_metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Location:\n    \"\"\"Metadata for the location of microgrid.\"\"\"\n\n    latitude: float | None = None\n    \"\"\"The latitude of the microgrid in degree.\"\"\"\n\n    longitude: float | None = None\n    \"\"\"The longitude of the microgrid in degree.\"\"\"\n\n    timezone: ZoneInfo | None = None\n    \"\"\"The timezone of the microgrid.\n\n    If not passed during construction (or `None` is passed), and there is a `longitude`\n    and `latitude`, then the timezone wil be looked up in a database based on the\n    coordinates. This lookup could fail, in which case the timezone will still be\n    `None`.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize the timezone of the microgrid.\"\"\"\n        if self.latitude is None or self.longitude is None or self.timezone is not None:\n            return\n\n        timezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\n        if timezone:\n            # The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\n            object.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float | None = None\n</code></pre> <p>The latitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float | None = None\n</code></pre> <p>The longitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.timezone","title":"timezone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timezone: ZoneInfo | None = None\n</code></pre> <p>The timezone of the microgrid.</p> <p>If not passed during construction (or <code>None</code> is passed), and there is a <code>longitude</code> and <code>latitude</code>, then the timezone wil be looked up in a database based on the coordinates. This lookup could fail, in which case the timezone will still be <code>None</code>.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Initialize the timezone of the microgrid.</p> Source code in <code>frequenz/client/microgrid/_metadata.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize the timezone of the microgrid.\"\"\"\n    if self.latitude is None or self.longitude is None or self.timezone is not None:\n        return\n\n    timezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\n    if timezone:\n        # The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\n        object.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata","title":"frequenz.client.microgrid.Metadata  <code>dataclass</code>","text":"<p>Metadata for the microgrid.</p> Source code in <code>frequenz/client/microgrid/_metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Metadata:\n    \"\"\"Metadata for the microgrid.\"\"\"\n\n    microgrid_id: int | None = None\n    \"\"\"The ID of the microgrid.\"\"\"\n\n    location: Location | None = None\n    \"\"\"The location of the microgrid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: Location | None = None\n</code></pre> <p>The location of the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata.microgrid_id","title":"microgrid_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int | None = None\n</code></pre> <p>The ID of the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData","title":"frequenz.client.microgrid.MeterData  <code>dataclass</code>","text":"<p>               Bases: <code>ComponentData</code></p> <p>A wrapper class for holding meter data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass MeterData(ComponentData):\n    \"\"\"A wrapper class for holding meter data.\"\"\"\n\n    active_power: float\n    \"\"\"The total active 3-phase AC power, in Watts (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    active_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    reactive_power: float\n    \"\"\"The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    reactive_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).\n\n    The provided values are for phase 1, 2, and 3 respectively.\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line\n        1,2 and 3 respectively.\n    \"\"\"\n\n    frequency: float\n    \"\"\"The AC power frequency in Hertz (Hz).\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create MeterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of MeterData created from the protobuf message.\n        \"\"\"\n        meter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.meter.data.ac.power_active.value,\n            active_power_per_phase=(\n                raw.meter.data.ac.phase_1.power_active.value,\n                raw.meter.data.ac.phase_2.power_active.value,\n                raw.meter.data.ac.phase_3.power_active.value,\n            ),\n            reactive_power=raw.meter.data.ac.power_reactive.value,\n            reactive_power_per_phase=(\n                raw.meter.data.ac.phase_1.power_reactive.value,\n                raw.meter.data.ac.phase_2.power_reactive.value,\n                raw.meter.data.ac.phase_3.power_reactive.value,\n            ),\n            current_per_phase=(\n                raw.meter.data.ac.phase_1.current.value,\n                raw.meter.data.ac.phase_2.current.value,\n                raw.meter.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.meter.data.ac.phase_1.voltage.value,\n                raw.meter.data.ac.phase_2.voltage.value,\n                raw.meter.data.ac.phase_3.voltage.value,\n            ),\n            frequency=raw.meter.data.ac.frequency.value,\n        )\n        meter_data._set_raw(raw=raw)\n        return meter_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The total active 3-phase AC power, in Watts (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.active_power_per_phase","title":"active_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>active_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively.</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>The AC power frequency in Hertz (Hz).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.reactive_power","title":"reactive_power  <code>instance-attribute</code>","text":"<pre><code>reactive_power: float\n</code></pre> <p>The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.reactive_power_per_phase","title":"reactive_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>reactive_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).</p> <p>The provided values are for phase 1, 2, and 3 respectively.</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create MeterData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of MeterData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create MeterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of MeterData created from the protobuf message.\n    \"\"\"\n    meter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.meter.data.ac.power_active.value,\n        active_power_per_phase=(\n            raw.meter.data.ac.phase_1.power_active.value,\n            raw.meter.data.ac.phase_2.power_active.value,\n            raw.meter.data.ac.phase_3.power_active.value,\n        ),\n        reactive_power=raw.meter.data.ac.power_reactive.value,\n        reactive_power_per_phase=(\n            raw.meter.data.ac.phase_1.power_reactive.value,\n            raw.meter.data.ac.phase_2.power_reactive.value,\n            raw.meter.data.ac.phase_3.power_reactive.value,\n        ),\n        current_per_phase=(\n            raw.meter.data.ac.phase_1.current.value,\n            raw.meter.data.ac.phase_2.current.value,\n            raw.meter.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.meter.data.ac.phase_1.voltage.value,\n            raw.meter.data.ac.phase_2.voltage.value,\n            raw.meter.data.ac.phase_3.voltage.value,\n        ),\n        frequency=raw.meter.data.ac.frequency.value,\n    )\n    meter_data._set_raw(raw=raw)\n    return meter_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted","title":"frequenz.client.microgrid.OperationAborted","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was aborted.</p> <p>Typically due to a concurrency issue or transaction abort.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationAborted(GrpcError):\n    \"\"\"The operation was aborted.\n\n    Typically due to a concurrency issue or transaction abort.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was aborted\",\n            grpc_error=grpc_error,\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was aborted\",\n        grpc_error=grpc_error,\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationAborted.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled","title":"frequenz.client.microgrid.OperationCancelled","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was cancelled.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationCancelled(GrpcError):\n    \"\"\"The operation was cancelled.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was cancelled\",\n            grpc_error=grpc_error,\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was cancelled\",\n        grpc_error=grpc_error,\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationCancelled.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented","title":"frequenz.client.microgrid.OperationNotImplemented","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation is not implemented or not supported/enabled in this service.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationNotImplemented(GrpcError):\n    \"\"\"The operation is not implemented or not supported/enabled in this service.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation is not implemented or not supported/enabled in \"\n            \"this service\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation is not implemented or not supported/enabled in \"\n        \"this service\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationNotImplemented.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange","title":"frequenz.client.microgrid.OperationOutOfRange","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was attempted past the valid range.</p> <p>Unlike InvalidArgument, this error indicates a problem that may be fixed if the system state changes.</p> <p>There is a fair bit of overlap with OperationPreconditionFailed, this error is just a more specific version of that error and could be the result of an operation that doesn't even take any arguments.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationOutOfRange(GrpcError):\n    \"\"\"The operation was attempted past the valid range.\n\n    Unlike [InvalidArgument][frequenz.client.base.exception.InvalidArgument], this error\n    indicates a problem that may be fixed if the system state changes.\n\n    There is a fair bit of overlap with\n    [OperationPreconditionFailed][frequenz.client.base.exception.OperationPreconditionFailed],\n    this error is just a more specific version of that error and could be the result of\n    an operation that doesn't even take any arguments.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was attempted past the valid range\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the system state changes it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was attempted past the valid range\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the system state changes it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationOutOfRange.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed","title":"frequenz.client.microgrid.OperationPreconditionFailed","text":"<p>               Bases: <code>GrpcError</code></p> <p>The operation was rejected because the system is not in a required state.</p> <p>For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. The user should perform some corrective action before retrying the operation.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationPreconditionFailed(GrpcError):\n    \"\"\"The operation was rejected because the system is not in a required state.\n\n    For example, the directory to be deleted is non-empty, an rmdir operation is applied\n    to a non-directory, etc. The user should perform some corrective action before\n    retrying the operation.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The operation was rejected because the system is not in a \"\n            \"required state\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the system state changes it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The operation was rejected because the system is not in a \"\n        \"required state\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the system state changes it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationPreconditionFailed.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut","title":"frequenz.client.microgrid.OperationTimedOut","text":"<p>               Bases: <code>GrpcError</code></p> <p>The time limit was exceeded while waiting for the operationt o complete.</p> <p>For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationTimedOut(GrpcError):\n    \"\"\"The time limit was exceeded while waiting for the operationt o complete.\n\n    For operations that change the state of the system, this error may be returned even\n    if the operation has completed successfully. For example, a successful response from\n    a server could have been delayed long.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The time limit was exceeded while waiting for the operation \"\n            \"to complete\",\n            grpc_error=grpc_error,\n            retryable=True,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The time limit was exceeded while waiting for the operation \"\n        \"to complete\",\n        grpc_error=grpc_error,\n        retryable=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationTimedOut.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated","title":"frequenz.client.microgrid.OperationUnauthenticated","text":"<p>               Bases: <code>GrpcError</code></p> <p>The request does not have valid authentication credentials for the operation.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class OperationUnauthenticated(GrpcError):\n    \"\"\"The request does not have valid authentication credentials for the operation.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The request does not have valid authentication credentials \"\n            \"for the operation\",\n            grpc_error=grpc_error,\n            retryable=False,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The request does not have valid authentication credentials \"\n        \"for the operation\",\n        grpc_error=grpc_error,\n        retryable=False,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.OperationUnauthenticated.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied","title":"frequenz.client.microgrid.PermissionDenied","text":"<p>               Bases: <code>GrpcError</code></p> <p>The caller does not have permission to execute the specified operation.</p> <p>Note that when the operation is rejected due to other reasons, such as the resources being exhausted or the user not being authenticated at all, different errors should be catched instead (ResourceExhausted and OperationUnauthenticated respectively).</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class PermissionDenied(GrpcError):\n    \"\"\"The caller does not have permission to execute the specified operation.\n\n    Note that when the operation is rejected due to other reasons, such as the resources\n    being exhausted or the user not being authenticated at all, different errors should\n    be catched instead\n    ([ResourceExhausted][frequenz.client.base.exception.ResourceExhausted] and\n    [OperationUnauthenticated][frequenz.client.base.exception.OperationUnauthenticated]\n    respectively).\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The caller does not have permission to execute the specified \"\n            \"operation\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the user is granted permission it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The caller does not have permission to execute the specified \"\n        \"operation\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the user is granted permission it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.PermissionDenied.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted","title":"frequenz.client.microgrid.ResourceExhausted","text":"<p>               Bases: <code>GrpcError</code></p> <p>Some resource has been exhausted (for example per-user quota, disk space, etc.).</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ResourceExhausted(GrpcError):\n    \"\"\"Some resource has been exhausted (for example per-user quota, disk space, etc.).\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Some resource has been exhausted (for example per-user quota, \"\n            \"disk space, etc.)\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the resource is freed it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Some resource has been exhausted (for example per-user quota, \"\n        \"disk space, etc.)\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the resource is freed it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ResourceExhausted.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable","title":"frequenz.client.microgrid.ServiceUnavailable","text":"<p>               Bases: <code>GrpcError</code></p> <p>The service is currently unavailable.</p> <p>This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class ServiceUnavailable(GrpcError):\n    \"\"\"The service is currently unavailable.\n\n    This is most likely a transient condition, which can be corrected by retrying with\n    a backoff. Note that it is not always safe to retry non-idempotent operations.\n    \"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"The service is currently unavailable\",\n            grpc_error=grpc_error,\n            retryable=True,  # If the service becomes available it might succeed\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"The service is currently unavailable\",\n        grpc_error=grpc_error,\n        retryable=True,  # If the service becomes available it might succeed\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ServiceUnavailable.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError","title":"frequenz.client.microgrid.UnknownError","text":"<p>               Bases: <code>GrpcError</code></p> <p>There was an error that can't be described using other statuses.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class UnknownError(GrpcError):\n    \"\"\"There was an error that can't be described using other statuses.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"There was an error that can't be described using other statuses\",\n            grpc_error=grpc_error,\n            retryable=True,  # We don't know so we assume it's retryable\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"There was an error that can't be described using other statuses\",\n        grpc_error=grpc_error,\n        retryable=True,  # We don't know so we assume it's retryable\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnknownError.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus","title":"frequenz.client.microgrid.UnrecognizedGrpcStatus","text":"<p>               Bases: <code>GrpcError</code></p> <p>The gRPC server returned an unrecognized status code.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>class UnrecognizedGrpcStatus(GrpcError):\n    \"\"\"The gRPC server returned an unrecognized status code.\"\"\"\n\n    def __init__(\n        self, *, server_url: str, operation: str, grpc_error: AioRpcError\n    ) -&gt; None:\n        \"\"\"Create a new instance.\n\n        Args:\n            server_url: The URL of the server that returned the error.\n            operation: The operation that caused the error.\n            grpc_error: The gRPC error originating this exception.\n        \"\"\"\n        super().__init__(\n            server_url=server_url,\n            operation=operation,\n            description=\"Got an unrecognized status code\",\n            grpc_error=grpc_error,\n            retryable=True,  # We don't know so we assume it's retryable\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = description\n</code></pre> <p>The human-readable description of the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus.grpc_error","title":"grpc_error  <code>instance-attribute</code>","text":"<pre><code>grpc_error: AioRpcError = grpc_error\n</code></pre> <p>The original gRPC error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus.is_retryable","title":"is_retryable  <code>instance-attribute</code>","text":"<pre><code>is_retryable = retryable\n</code></pre> <p>Whether retrying the operation might succeed.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation = operation\n</code></pre> <p>The operation that caused the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus.server_url","title":"server_url  <code>instance-attribute</code>","text":"<pre><code>server_url = server_url\n</code></pre> <p>The URL of the server that returned the error.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; None\n</code></pre> <p>Create a new instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error originating this exception.</p> <p> TYPE: <code>AioRpcError</code> </p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>def __init__(\n    self, *, server_url: str, operation: str, grpc_error: AioRpcError\n) -&gt; None:\n    \"\"\"Create a new instance.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error originating this exception.\n    \"\"\"\n    super().__init__(\n        server_url=server_url,\n        operation=operation,\n        description=\"Got an unrecognized status code\",\n        grpc_error=grpc_error,\n        retryable=True,  # We don't know so we assume it's retryable\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.UnrecognizedGrpcStatus.from_grpc_error","title":"from_grpc_error  <code>classmethod</code>","text":"<pre><code>from_grpc_error(\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError\n) -&gt; GrpcError\n</code></pre> <p>Create an instance of the appropriate subclass from a gRPC error.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server that returned the error.</p> <p> TYPE: <code>str</code> </p> <code>operation</code> <p>The operation that caused the error.</p> <p> TYPE: <code>str</code> </p> <code>grpc_error</code> <p>The gRPC error to convert.</p> <p> TYPE: <code>AioRpcError</code> </p> RETURNS DESCRIPTION <code>GrpcError</code> <p>An instance of GrpcError if the gRPC status is not recognized, or an appropriate subclass if it is.</p> Source code in <code>frequenz/client/base/exception.py</code> <pre><code>@classmethod\ndef from_grpc_error(\n    cls,\n    *,\n    server_url: str,\n    operation: str,\n    grpc_error: AioRpcError,\n) -&gt; GrpcError:\n    \"\"\"Create an instance of the appropriate subclass from a gRPC error.\n\n    Args:\n        server_url: The URL of the server that returned the error.\n        operation: The operation that caused the error.\n        grpc_error: The gRPC error to convert.\n\n    Returns:\n        An instance of\n            [GrpcError][frequenz.client.base.exception.GrpcError] if the gRPC status\n            is not recognized, or an appropriate subclass if it is.\n    \"\"\"\n\n    class Ctor(Protocol):\n        \"\"\"A protocol for the constructor of a subclass of `GrpcError`.\"\"\"\n\n        def __call__(\n            self, *, server_url: str, operation: str, grpc_error: AioRpcError\n        ) -&gt; GrpcError: ...\n\n    grpc_status_map: dict[grpc.StatusCode, Ctor] = {\n        grpc.StatusCode.CANCELLED: OperationCancelled,\n        grpc.StatusCode.UNKNOWN: UnknownError,\n        grpc.StatusCode.INVALID_ARGUMENT: InvalidArgument,\n        grpc.StatusCode.DEADLINE_EXCEEDED: OperationTimedOut,\n        grpc.StatusCode.NOT_FOUND: EntityNotFound,\n        grpc.StatusCode.ALREADY_EXISTS: EntityAlreadyExists,\n        grpc.StatusCode.PERMISSION_DENIED: PermissionDenied,\n        grpc.StatusCode.RESOURCE_EXHAUSTED: ResourceExhausted,\n        grpc.StatusCode.FAILED_PRECONDITION: OperationPreconditionFailed,\n        grpc.StatusCode.ABORTED: OperationAborted,\n        grpc.StatusCode.OUT_OF_RANGE: OperationOutOfRange,\n        grpc.StatusCode.UNIMPLEMENTED: OperationNotImplemented,\n        grpc.StatusCode.INTERNAL: InternalError,\n        grpc.StatusCode.UNAVAILABLE: ServiceUnavailable,\n        grpc.StatusCode.DATA_LOSS: DataLoss,\n        grpc.StatusCode.UNAUTHENTICATED: OperationUnauthenticated,\n    }\n\n    if ctor := grpc_status_map.get(grpc_error.code()):\n        return ctor(\n            server_url=server_url, operation=operation, grpc_error=grpc_error\n        )\n    return UnrecognizedGrpcStatus(\n        server_url=server_url,\n        operation=operation,\n        grpc_error=grpc_error,\n    )\n</code></pre>"}]}